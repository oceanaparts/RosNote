{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"readme.html":{"url":"readme.html","title":"前言","keywords":"","body":"Introduction Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part1/readme.html":{"url":"part1/readme.html","title":"1.catkin工作空间","keywords":"","body":"1.catkin工作空间:   catkin时针对ros定制的cmke扩展的编译系统，用来编译ros项目，工作空间就是该项目的文件夹 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part1/1.html":{"url":"part1/1.html","title":"1.1具体项目空间建立如下","keywords":"","body":"1.1具体项目空间建立如下： 建立工作空间：~代表在用户文件夹下 mkdir -p ~/项目空间名（文件夹名）/src 定位到工作空间 cd 项目空间名（文件夹名）/ 初始化工作空间，得到build文件夹（中间文件）与devel文件夹（目标文件，动态链接库） catkin_make 进入 src 创建 ros 包（功能包）并添加依赖（roscpp rospy std_msgs） cd src catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 通过上述操作得到 而src下又包含 其中helloworld就是一个功能包 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part1/2.html":{"url":"part1/2.html","title":"1.2编译","keywords":"","body":"1.2编译：   命令如下 cd 自定义空间名称 catkin_make source ./devel/setup.bash#编译完成刷新source环境（.代表在当前文件夹下--即上面cd到的空间） source生命周期只有在该终端中生效，关掉重新打开，或同时打开的另一个终端都无法生效，为了方便起见可以使用以下命令加入bashrc文件中，使其一直生效 source ./devel/setup.bash \">>~/.bashrc Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part2/readme.html":{"url":"part2/readme.html","title":"2.功能包中的src文件夹下分析","keywords":"","body":"2.功能包中的src文件夹下分析（不是与build平级的src): （基于中科院教程https://www.bilibili.com/video/BV1mJ411R7Ni/） src下放的是各种package（功能包），是编译的基本单元，每个package又可以被一同放在一个文件夹下，再放置于src下，每个package可以由各种语言共同构成，一般cpp放在source文件夹下，python放在scripts文件夹下；一个package可以包含多个可执行文件（节点），每个package下除了上述两个代码文件（scripts与source）以及include文件夹又包含着如下两文件（这两文件也是判断是不是package的方法） Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part2/1.html":{"url":"part2/1.html","title":"2.1 主要文件分析","keywords":"","body":"2.1主要文件分析 CMakeLists.txt 规定catkin编译规则，例如：源文件，依赖项、目标文件， 主要由以下几项构成 具体文件如下 如在第10行就是1.1下第四步的依赖包，如果写错了可以直接修改，记得同时修改xml文件 package.xml 定义了package的属性，例如：包名，版本号，作者，依赖等，主要由以下几项构成 一般修改build_depend与run_depend mainfest.xml 早期版本用rosbuild编译的产物相当于package.xml 代码文件 一般包含脚本文件（shell,python,放置在scripts文件夹下）与C++文件（源文件文件-放置在src文件夹下，头文件-放置在include文件夹下，src下也可放python文件-被其他包import的python文件） 通讯文件 一般是自定义的通信内容，如：消息（.msg），服务（.srv），动作（.action） 其他文件 launch文件（.launch）以及配置文件（.yaml放在config文件夹下） 所以整个src文件架构如下 补充：打印文件夹下的文件架构树可以在该文件下下打开终端然后使用 tree命令 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part3/readme.html":{"url":"part3/readme.html","title":"3.常用包管理指令","keywords":"","body":"3.常用包管理指令 （都要在#编译完成刷新source环境前提下执行） Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part3/1.html":{"url":"part3/1.html","title":"3.1 rospack list ","keywords":"","body":"3.1 rospack list 可以 rospack list | grep 包名 如果没有输出说明没有该包，或没有刷新source，这个命令其实是查找特点关键字的包 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part3/2.html":{"url":"part3/2.html","title":"3.2 git clone与安装依赖包","keywords":"","body":"3.2git clone与安装依赖包 （基于中科院教程https://www.bilibili.com/video/BV1mJ411R7Ni/） 补充：在build平级的src下使用 git clone可克隆功能包如: ``` git clone https://ghproxy.com/https://github.com/DroidAITech/ROS-Academy-for-Beginners.git ``` https://ghproxy.com/是国内的代理访问比较快 克隆后rosdep指令使用安装教学包所需的依赖（相关信息在cmakelists与xml文件里），需要在工作空间(此处是catkin_ws)下执行 $ cd ~/catkin_ws $ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #kinetic应替换作对应的ros版本 对于中科院的教程 发现会报错robot_sim_demo: Cannot locate rosdep definition for [yocs_cmd_vel_mux]无法找到该包，即使apt install 都不行（可能是把yocs-cmd-vel-mux打成yocs_cmd_vel_mux了）需要把 $ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 改成 rosdep install --from-paths ~/catkin_ws/src --ignore-src -r 或者参考以下两链接http://nicethemes.cn/news/txtlist_i142092v.html或https://blog.csdn.net/fanshuaifang/article/details/107100112 克隆后记得编译并刷新环境 $ catkin_make(在工作空间下执行) $ source ~/catkin_ws/devel/setup.bash Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part3/3.html":{"url":"part3/3.html","title":"3.3 rosls","keywords":"","body":"3.3rosls 与ls类似，查看文件夹下的文件 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part4/readme.html":{"url":"part4/readme.html","title":"4.Metpackage","keywords":"","body":"4.Metpackage 包含着各种依赖包，把包组合起来，自身没有实际内容，之前也称作stack，功能包集，软件包集，如ros官方的navigation包，常用包如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part5/readme.html":{"url":"part5/readme.html","title":"5.常用包管理指令","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part5/1.html":{"url":"part5/1.html","title":"5.1 master","keywords":"","body":"5.1 master master是节点管理器，每个节点（node）启动时都要向master注册，master管理着节点之间的通信，通过roscore命令启动master，roscore同时还启动了rosout日志输出，主要告诉我们系统有什么error与waring，roscore还启动了parameter server参数服务器 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part5/2.html":{"url":"part5/2.html","title":"5.2 node","keywords":"","body":"5.2 node 一个node就是一个进程，之前提到pkg里可以有多个可执行文件（python脚本，c++编译的），运行了这些可执行文件，他们被加载到进程中就成为一个node node的启动：rosrun 包名 连接的C++节点名（也就是源文件映射名称，是CMakeLists中的，如果是py脚本则rosrun 包名 py文件名） 显示某个node的详细信息:rosnode info ros节点名（ros::init的） 列出当前运行的node信息:rosnode list(如果使用rosrun运行的节点显示的是ros::init的节点名，如果是用roslaunch运行的节点则是在launch文件中的name值) 结束某个node：rosnode kill 节点名（ros::init的） ！！！！同时启动多个node: 将信息放在launch文件下后roslaunch 包名 launch文件名.launch并且此命令会自动检查时候运行了roscore没有会自动先启动roscore，并且此命令无需关心在哪个文件夹下执行，但是运行前一样要source Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part5/3.html":{"url":"part5/3.html","title":"5.3 launch文件","keywords":"","body":"5.3 launch文件 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/1.html":{"url":"part6/1.html","title":"6.1 Topic通讯","keywords":"","body":"6.1 Topic通讯 两个node要通讯，一般会先定义好共同话题，像一个频道，如下图所示 nodeA调用publish方法发送，nodeB调用subscribe方法订阅。 异步是发送者不管接受者时候收到是否有接受者，不用管消息的反馈，接受者不管发送者是谁 一个Topic可以有多个node订阅，也可以有多个node发送 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/2.html":{"url":"part6/2.html","title":"6.2 Message","keywords":"","body":"6.2 Message topic内容的数据类型定义在.msg文件中，是topic通讯的数据类型 msg可以嵌套msg，也就是一个msg类型里面可以调用其他类型的msg msg像是一个类或者说结构体，每次发送都是一个该类实例化的对象 常用命令如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/3.html":{"url":"part6/3.html","title":"6.3 Topic与msg具体操作","keywords":"","body":"6.3 Topic与msg具体操作 使用rosnode list查看哪些节点在运行 使用rosnode info 节点名(注意前面的斜杠) 查看节点具体信息 connections后面的topic即使与之相联系的topic频道 使用rostopic info topic名（注意前面的斜杠） 查看topic具体信息 publishers就是这个topic频道的发送者，subscribers就是这个topic频道的接收者 其中的Type信息就是该Topic通讯的msg类，可以使用rosmsg show 这个Type，就能看到这个msg类型的具体组成： rosmsg show msg类型名，显示具体组成 rostopic echo topic名（注意前面的斜杠）显示在该通道里通讯的具体信息（实时的） 使用msg需要修改package.xml文件与cmkelists文件 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/4.html":{"url":"part6/4.html","title":"6.4 Service通讯","keywords":"","body":"6.4 Service通讯 多用于类似以下场景，一个node需要大量计算资源（如人体姿势识别等深度学习），但是接受的node只是有时候需要，这样的话，如果使用Topic的话，发送的node就是在大量的计算，切是无用的计算，太过占用资源，这就是Topic异步通讯的缺点。 而Service的话nodeA使用request方法，发送参数给nodeB，使nodeB计算，并且nodeA会一直阻塞等待，直到nodeB的计算结果反馈,nodeA才会继续执行 可以多个client对应同一个service >对比如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/5.html":{"url":"part6/5.html","title":"6.5 srv","keywords":"","body":"6.5 srv 与msg之于Topic的关系类似，srv是service通讯的数据格式，定义在.srv文件中,srv里的数据格式可以是定义的msg如下图 DetectHuman.srv是用于人体姿势检测的srv数据格式, bool start_detect是用于request的，为True时执行检测 my_pkg/HumanPose[] pose_data适用于replay的之所以为数组是因为可能检测到的不止一个人，而my_pkg/HumanPose是一种msg 使用msg与srv时需要修改package.xml文件与cmkelists文件 常用命令如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/6.html":{"url":"part6/6.html","title":"6.6 参数服务器Parameter Server","keywords":"","body":"6.6 参数服务器Parameter Server 储存各种参数的字典 可用 **命令行，launch文件和node（API)**等方法进行读写 常用命令行如下： 其中dump与load的文件格式必须遵循yaml格式 也可以在launch.xml文件（主要是各种标签）里对参数进行读写，与参数服务器相关的标签主要是param与rosparam标签 ^第一个标签是 用xacro.py去执行robot.xacro文件得到结果作为字典的value ^第二个标签相当于使用了load命令load了一个yaml文件 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/7.html":{"url":"part6/7.html","title":"6.7 Service与srv具体操作","keywords":"","body":"6.7 Service与srv具体操作 rosservice info ^Type就是这个service的通讯的srv类型 rossrv show ^srting light_name 是发送的request信息（参数），bool succees与string status_message是reply的信息，这个实例是删除light的实例，返回的信息就是是否删除灯光如下 rosservice call ^后面的\"light_name:''\"是request的参数，可以双击Tab键来自动跳出，补全提示需要什么样的参数 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part6/8.html":{"url":"part6/8.html","title":"6.8 rosparam具体操作","keywords":"","body":"6.8 rosparam具体操作 1.rosparam list ：列举所有参数的KEY 2.rosparam get 3.rosparam dump：保存所有参数的yaml文件 4.使用vi命令打开yaml文件 ^注意上面的camera参数字典是字典套字典 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/1.html":{"url":"part7/1.html","title":"7.1 创建 ROS 工作空间","keywords":"","body":"7.1 创建 ROS 工作空间 mkdir -p 工作空间名/src(必须得有 src)   得到工作空间文件夹（-p指向ubuntu用户文件夹，该实例工作空间命名为demo_service）---Topic实例但是命名为service，这确实是个失误，无伤大雅，主要是后来才发现，来不及修改了   目前在该文件夹下只有src文件夹 cd定位到工作空间文件夹后初始化 cd 工作空间名   该实例就是cd demo_service 接着在该文件夹下初始化工作空间 catkin_make 则工作空间文件夹demo_service下有了build与devel文件夹 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/2.html":{"url":"part7/2.html","title":"7.2 在工作空间文件夹找下启动 vscode","keywords":"","body":"7.2 在工作空间文件夹找下启动 vscode cd 工作空间文件夹名 code .（后面有个点.不要忘了） 在该实例就是 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/3.html":{"url":"part7/3.html","title":"7.3 在vscode 中编译 ros（配置编译环境）","keywords":"","body":"7.3 在vscode 中编译 ros（配置编译环境） 1.vs code界面下左键选中src文件夹按下快捷键 ctrl + shift + B 调用编译出现如下选项 点击第二个后面的小齿轮，则出现.vscode文件夹 其中tasks.json文件： 复制粘贴为以下代码 { // 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"catkin_make:debug\", //代表提示的描述性信息 \"type\": \"shell\", //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行 \"command\": \"catkin_make\",//这个是我们需要运行的命令 \"args\": [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2” \"group\": {\"kind\":\"build\",\"isDefault\":true}, \"presentation\": { \"reveal\": \"always\"//可选always或者silence，代表是否输出信息 }, \"problemMatcher\": \"$msCompile\" } ] } 通过以上操作我们完成编译环境配置，后期直接ctrl + shift + B 完成编译 以后如果还需要其实可以直接复制粘贴.vscode文件夹 PS1: 如果没有代码提示修改 .vscode/c_cpp_properties.json设置 \"cppStandard\": \"c++17\" PS2: main 函数的参数不可以被 const 修饰 PS3: 当ROS__INFO 终端输出有中文时，会出现乱码，在代码中加入 setlocale(LC_ALL,\"\");设置编码即可 ------------到上面C++编译环境就创建完成------------ Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/4.html":{"url":"part7/4.html","title":"7.4 创建 ROS 功能包","keywords":"","body":"7.4 创建 ROS 功能包   选定 src 右击 ---> create catkin package，跳出如下选项，输入功能包名，该实例命名为plumbing_pub_sub回车确定   回车后提示输入依赖包，这里输入为常用的roscpp rospy std_msgs，回车确定 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/5.html":{"url":"part7/5.html","title":"7.5 编写发布者代码","keywords":"","body":"7.5编写发布者代码 在功能包文件夹plumbing_pub_sub下的src右键创建cpp源文件，该实例中命名为demo_pub.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" int main(int argc,char *argv[]) { //2.初始化 ROS 节点:命名(唯一) // 参数1和参数2 后期为节点传值会使用 // 参数3 是节点名称，是一个标识符，需要保证运行后，在 ROS 网络拓扑中唯一 ros::init(argc,argv,\"erGouzhi\"); //3.实例化 ROS 句柄 该类封装了 ROS 中的一些常用功能 ros::NodeHandle nh; //4.实例化 发布者 对象 //泛型: 发布的消息类型 //参数1: 要发布到的话题 //参数2: 队列中最大保存的消息数，超出此阀值时，先进的先销毁(时间早的先销毁) ros::Publisher pub_erGouzhi=nh.advertise(\"demo_service_topic\",10); //实例化一个String 数据 用于存放消息 std_msgs::String demo_service_msg; while(ros::ok()) //节点不死 { demo_service_msg.data=\"hello\"; pub_erGouzhi.publish(demo_service_msg); } return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/6.html":{"url":"part7/6.html","title":"7.6 修改CMakeLists.txt文件","keywords":"","body":"7.6修改CMakeLists.txt文件   第136行左右修改 `add_executable`   参数一是节点源文件映射链接名称，自定义，可以不与程序中初始化的节点名称（即上面程序的\"erGouzhi\"）一样   参数二是对应的源文件名称   即修改为如下   第149行左右修改 只需修改参数一，与第136行命名的节点源文件映射链接名称一致，即如下图所示 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/7.html":{"url":"part7/7.html","title":"7.7 编译运行","keywords":"","body":"7.7编译文件 ctrl + shift + B 输出如下 运行 roscore cd 工作空间文件夹 source ./devel/setup.bash rosrun 包名 C++节点（源文件映射名称,CMakeLists.txt中的add_executable的参数一） Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/8.html":{"url":"part7/8.html","title":"7.8 运行结果分析","keywords":"","body":"7.8 运行结果分析 发现无输出，因为即没有订阅者，也没有日志输出，所以控制台无输出正常 在另一个终端调用rostopic list ,输出如下 发现有/demo_service_topic的topic，则topic正常运行 接着rostopic info +topic话题名称 发现msg类型为std_msgs/String，正是我们所设置的的topic的msg类型 使用rostopic echo +topic话题名称 发现终端一致输出hello符合预期，编写正确 ctrl+c结束rostopic echo的运行（节点依然在运行） Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/9.html":{"url":"part7/9.html","title":"7.9 节点的结束","keywords":"","body":"7.9 节点的结束 使用rosnode kill +节点名称（ros::init的名称），如下图所示 kill后就没有/demo_service_topic的topicle 也没有这个node节点了，使用rosnode list发现节点已经不在运行了 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/10.html":{"url":"part7/10.html","title":"7.10 完善发布逻辑","keywords":"","body":"7.10 完善发布逻辑 代码修改为如下，实现10hz的发布并完成数据拼接， 输出中文日志信息 #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include int main(int argc,char *argv[]) { //设置编码 避免中文日至输出乱码 setlocale(LC_ALL,\"\"); //2.初始化 ROS 节点:命名(唯一) // 参数1和参数2 后期为节点传值会使用 // 参数3 是节点名称，是一个标识符，需要保证运行后，在 ROS 网络拓扑中唯一 ros::init(argc,argv,\"erGouzhi\"); //3.实例化 ROS 句柄 该类封装了 ROS 中的一些常用功能 ros::NodeHandle nh; //4.实例化 发布者 对象 //泛型: 发布的消息类型 //参数1: 要发布到的话题 //参数2: 队列中最大保存的消息数，超出此阀值时，先进的先销毁(时间早的先销毁) ros::Publisher pub_erGouzhi=nh.advertise(\"demo_service_topic\",10); //实例化一个String 数据 用于存放消息 std_msgs::String demo_service_msg; ros::Rate rate(10);//10hz的频率 int count=0; while(ros::ok()) //节点不死 { count++; //demo_service_msg.data=\"hello\"; //数据拼接 实例化对象 std::stringstream ss; //拼接 ss\"输出结果如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/11.html":{"url":"part7/11.html","title":"7.11 编写订阅者代码","keywords":"","body":"7.11 编写订阅者代码 在功能包文件夹plumbing_pub_sub下的src右键创建订阅者cpp源文件，该实例中命名为demo_sub.cpp 代码如下： /* 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) 消息订阅方: 订阅话题并打印接收到的消息 实现流程: 1.包含头文件 2.初始化 ROS 节点:命名(唯一) 3.实例化 ROS 句柄 4.实例化 订阅者 对象 5.处理订阅的消息(回调函数) 6.设置循环调用回调函数 */ // 1.包含头文件 #include \"ros/ros.h\" #include \"std_msgs/String.h\" void doMsg(const std_msgs::String::ConstPtr& msg_p){ ROS_INFO(\"我听见:%s\",msg_p->data.c_str()); // ROS_INFO(\"我听见:%s\",(*msg_p).data.c_str()); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //2.初始化 ROS 节点:命名(唯一) ros::init(argc,argv,\"listener\"); //3.实例化 ROS 句柄 ros::NodeHandle nh; //4.实例化 订阅者 对象 //泛型: 接收的消息类型 要与发布方一致 //参数1: 要接收的话题 要与发布方一致 ros::Subscriber sub = nh.subscribe(\"demo_service_topic\",10,doMsg); //5.处理订阅的消息(回调函数) // 6.设置循环调用回调函数 不停的调用sub的回调函数doMsg 在调用后不会再返回，也就是你的主程序到这儿就不往下执行了， ros::spin();//循环读取接收的数据，并调用回调函数处理 return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/12.html":{"url":"part7/12.html","title":"7.12 修改CMakeLists.txt文件","keywords":"","body":"7.12 修改CMakeLists.txt文件 参考7.6修改为如下图所示： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/13.html":{"url":"part7/13.html","title":"7.13 编译运行","keywords":"","body":"7.13 编译文件 ctrl + shift + B 运行 在终端中先运行发布者节点（在已经运行roscore前提下，没有就先roscore）： rosrun plumbing_pub_sub demo_pub_node 再新建终端,输入 source ./devel/setup.bash（新开终端了，要重新source） rosrun plumbing_pub_sub demo_sub_node 结果如下，符合预期 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/14.html":{"url":"part7/14.html","title":"7.14 补充","keywords":"","body":"7.14 补充 补充0: vscode 中的 main 函数 声明 int main(int argc, char const *argv[]){}，默认生成 argv 被 const 修饰，需要去除该修饰符 补充1: ros/ros.h No such file or directory ..... 检查 CMakeList.txt find_package 出现重复,删除内容少的即可 参考资料:https://answers.ros.org/question/237494/fatal-error-rosrosh-no-such-file-or-directory/ 补充2: find_package 不添加一些包，也可以运行啊， ros.wiki 答案如下 You may notice that sometimes your project builds fine even if you did not call find_package with all dependencies. This is because catkin combines all your projects into one, so if an earlier project calls find_package, yours is configured with the same values. But forgetting the call means your project can easily break when built in isolation. 补充3: 订阅时，前几条数据丢，就算先运行订阅者节点再运行发布者节点也会丢失 原因: 发送前几条数据时， publisher 还未在 roscore 注册完毕 （5.1小节--master是节点管理器，每个节点（node）启动时都要向master注册，master管理着节点之间的通信，通过roscore命令启动master），就已经将数据发出，但是未注册，自然无法接受 解决: 注册后，再发送语句前，加入休眠 ros::Duration(3.0).sleep(); 延迟3秒，延迟前几条数据的发送 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/15.html":{"url":"part7/15.html","title":"7.15 使用launch同时启动多个节点","keywords":"","body":"7.15 使用launch同时启动多个节点 前面需要先输入命令启动发布者节点，再输入命令启动订阅者节点，一旦节点过多，一个个输入命令去启动所有节点是不现实的解决办法就是使用launch文件，可以一次性启动多个ROS节点。 1、在vscode中选定功能包右击 ---> 添加 launch 文件夹2、选定 launch 文件夹右击 ---> 添加 launch 文件，文件名自定义，这里写作start_demo.launch 3、编辑 launch 文件内容 其中 node ---> 包含的某个节点 pkg -----> 功能包名 type ----> 被运行的节点源文件映射名称,即CMakeLists中的add_executable的参数一 name --> 为节点命名，随意取，rosnode list出来的就是这个名字了，而不是CMakeLists中的add_executable的参数一，而rosrun运行节点后rosnode list显示的在程序中初始化的节点名称 output-> 设置日志的输出目标 ，如果程序有日志输出，需要添加该指令，否则无输出。如果用rosrun指令运行节点则不用。 4、ctrl+shift+b编译5、roscore6、在工作空间文件夹下source ./devel/setup.bash7、roslaunch 包名 launch文件名在这里是roslaunch plumbing_pub_sub start_demo.launch8、运行结果如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/16.html":{"url":"part7/16.html","title":"7.16 使用launch运行与rosrun运行结果的区别","keywords":"","body":"7.16 使用launch运行与rosrun运行结果的区别 1、节点名称的差异 观察上面观察上面两个图片可以发现，使用rosrun指令运行，输出日志时，程序中虽然没有标明输出端是屏幕screen，但依旧输出了数据，同时使用rosnode list命令去观察运行的节点名称，可以发现运行的节点名称是程序中节点初始化时的命名名称。而使用roslaunch运行的结果如上面8、所示是节点名称为在launch文件中的name值 2、在日志输出方面的差异 需要指明输出output的值，才可以输出日志。将*.launch文件修改为如下图所示可以发现， 结果如下 两个日志都输出了，只有只有一个日志输出，因为只为发送者节点设置了输出，符合预期 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part7/17.html":{"url":"part7/17.html","title":"7.17 计算图查看","keywords":"","body":"7.17 计算图查看 roslaunch plumbing_pub_sub start_demo.launch 运行两节点后 rqt_graph 得到如下结果，将通讯的结构图完整呈现出来 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/readme.html":{"url":"part8/readme.html","title":"8.Topic通讯操作实例(Python版)--包含vscode运行python环境","keywords":"","body":"8.Topic通讯操作实例(Python版)--包含vscode运行python环境 以下教程基于https://www.bilibili.com/video/BV1Ci4y1L7ZZ/文档http://www.autolabor.com.cn/book/ROSTutorials/实现环境 ubuntu+ros noetic +vscode(安装c/c++,python,ros,cmake tools插件) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/1.html":{"url":"part8/1.html","title":"8.1 发布方代码编写","keywords":"","body":"8.1 发布方代码编写 在7小节的项目，功能包plumbing_pub_sub目录下创建scripts文件夹，接着在scripts文件夹下创建发布方程序文件，命名为demo_pub_p.py 编写代码（注意第一行#! /usr/bin/env python声明了解释器） #! /usr/bin/env python \"\"\" 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) PS: 二者需要设置相同的话题 消息发布方: 循环发布信息:HelloWorld 后缀数字编号 实现流程: 1.导包 2.初始化 ROS 节点:命名(唯一) 3.实例化 发布者 对象 4.组织被发布的数据，并编写逻辑发布数据 \"\"\" #1.导包 import rospy from std_msgs.msg import String if __name__ == \"__main__\": #2.初始化 ROS 节点:命名(唯一) rospy.init_node(\"talker_p\") #3.实例化 发布者 对象 pub = rospy.Publisher(\"chatter\",String,queue_size=10) #4.组织被发布的数据，并编写逻辑发布数据 msg = String() #创建 msg 对象 msg_front = \"hello 你好\" count = 0 #计数器 # 设置循环频率 rate = rospy.Rate(1) while not rospy.is_shutdown(): #拼接字符串 msg.data = msg_front + str(count) pub.publish(msg) rate.sleep() rospy.loginfo(\"写出的数据:%s\",msg.data) count += 1 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/2.html":{"url":"part8/2.html","title":"8.2 订阅方代码编写","keywords":"","body":"8.2 订阅方代码编写 在scripts文件夹下创建订阅方程序文件，命名为demo_sub_p.py 编写代码如下（注意第一行#! /usr/bin/env python声明了解释器） #! /usr/bin/env python \"\"\" 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) 消息订阅方: 订阅话题并打印接收到的消息 实现流程: 1.导包 2.初始化 ROS 节点:命名(唯一) 3.实例化 订阅者 对象 4.处理订阅的消息(回调函数) 5.设置循环调用回调函数 \"\"\" #1.导包 import rospy from std_msgs.msg import String def doMsg(msg): rospy.loginfo(\"I heard:%s\",msg.data) if __name__ == \"__main__\": #2.初始化 ROS 节点:命名(唯一) rospy.init_node(\"listener_p\") #3.实例化 订阅者 对象 sub = rospy.Subscriber(\"chatter\",String,doMsg,queue_size=10) #4.处理订阅的消息(回调函数) #5.设置循环调用回调函数 rospy.spin() Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/3.html":{"url":"part8/3.html","title":"8.3 添加可执行权限","keywords":"","body":"8.3 添加可执行权限 终端下进入 scripts 执行: chmod +x *.py PS:就是.py ，不是文件完整名称，这样会对所有python文件添加可执行权限结果如下，单纯 chmod +x .py 没有输出，可以用ll指令 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/4.html":{"url":"part8/4.html","title":"8.4 配置 CMakeLists.txt","keywords":"","body":"8.4 配置 CMakeLists.txt 165行左右 修改为如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part8/5.html":{"url":"part8/5.html","title":"8.5编译运行","keywords":"","body":"8.5编译运行 ctrl +shift+b编译 在工作空间下 roscore source ./devel/setup.bash 之后 rosrun plumbing_pub_sub demo_pub_p.py （rosrun 包名 完整py文件名） 结果如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/readme.html":{"url":"part9/readme.html","title":"9.自定义msg","keywords":"","body":"9.自定义msg ROS 中通过 std_msgs 封装了一些原生的数据类型,比如:String、Int32、Int64、Char、Bool、Empty.... 但是，这些数据一般只包含一个 data 字段，结构的单一意味着功能上的局限性，当传输一些复杂的数据，比如: 激光雷达的信息... std_msgs 由于描述性较差而显得力不从心，这种场景下可以使用自定义的消息类型msgs只是简单的文本文件，每行具有字段类型和字段名称，可以使用的字段类型有： int8, int16, int32, int64 (或者无符号类型: uint*) float32, float64 string time, duration other msg files variable-length array[] and fixed-length array[C] ROS中还有一种特殊类型：Header，标头包含时间戳和ROS中常用的坐标帧信息。会经常看到msg文件的第一行具有Header标头。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/1.html":{"url":"part9/1.html","title":"9.1 新建与编写msg文件（基于8小节的工程项目下进行）","keywords":"","body":"9.1新建与编写msg文件（基于8小节的工程项目下进行） 在8小节的功能包下右键新建msg文件夹，接着在msg文件夹下右键新建msg文件这里命名为Person.msg，并编写代码，最终如下图所示。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/2.html":{"url":"part9/2.html","title":"9.2 修改package.xml文件","keywords":"","body":"9.2修改package.xml文件 原本如下 修改为如下 原理： 是功能包编译时的依赖的相关包 是功能执行时的依赖的相关包 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/3.1.html":{"url":"part9/3.1.html","title":"9.3.1 find_package修改","keywords":"","body":"9.3.1find_package修改 增加message_generation依赖，这个依赖是帮助我们生成自定义的msg文件的，修改完如下所示 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/3.2.html":{"url":"part9/3.2.html","title":"9.3.2 add_message_files修改","keywords":"","body":"9.3.2add_message_files修改 原本如下： 增加自己定义的msg文件，即修改为如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/3.3.html":{"url":"part9/3.3.html","title":"9.3.3 generate_messages修改","keywords":"","body":"9.3.3generate_messages修改 这个宏才会真正的把msg文件生成为对应的头文件原本如下： 直接取消注释，即修改为如下，因为欲编译Person.msg需依赖于std_msgs因为在Person.msg中用到的string int32 float32都是std_msgs里的类型 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/3.4.html":{"url":"part9/3.4.html","title":"9.3.4 catkin_package修改","keywords":"","body":"9.3.4 catkin_package修改 该项是与find_package相联系的，find_package是告诉编译系统，编译这个功能包需要依赖于find_package里的功能包，而find_package里的功能包又得依赖于catkin_package的功能包，如果find_package编写有问题可能导致编译失败，如果catkin_package编写有问题可能导致编译没问题，但是运行时出现问题原本如下： 修改为如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/4.1.html":{"url":"part9/4.1.html","title":"9.4.1 编译后的中间文件查看（C++）","keywords":"","body":"9.4.1编译后的中间文件查看（C++）: C++ 需要调用的中间文件(.../工作空间/devel/include/包名/xxx.h) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part9/4.2.html":{"url":"part9/4.2.html","title":"9.4.2 编译后的中间文件查看（Python）","keywords":"","body":"9.4.2编译后的中间文件查看（Python）: C++ 需要调用的中间文件(.../工作空间/devel/lib/python3/dist-packages/msg/xxx.py) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part10/1.html":{"url":"part10/1.html","title":"10.1 准备工作-vscode配置","keywords":"","body":"10.1准备工作-vscode配置（c_cpp_properties.json文件修改） 该步一是为了防止误抛异常二是为了代码提示 我们对c_cpp_properties.json 文件进行修改 在这里把刚才生成的C++中间文件--头文件的路径包含过来，可以在vscode右键选中文件后复制路径，在复制的基础上进行修改，复制而来的路径为 /home/rosnoetic/demo_service/devel/include/plumbing_pub_sub/Person.h 把后面的包名以及具体头文件名去掉，改为这样就可以对该路径下的所有的头文件进行包含，不用每次都修改，即修改为如下 /home/rosnoetic/demo_service/devel/include/ 则c_cpp_properties.json原来如下： 修改为： 注意语句后面的逗号不要丢了 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part10/2.html":{"url":"part10/2.html","title":"10.2 发布方实现","keywords":"","body":"10.2发布方实现 在src下右键新建demo_msg_pub.cpp文件代码如下：（详见注释） /* 需求: 循环发布人的信息 */ #include \"ros/ros.h\" #include \"plumbing_pub_sub/Person.h\" //消息类头文件的包含,由于在c_cpp_properties中已经包含到include所以这边从plumbing_pub_sub开始 int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //1.初始化 ROS 节点 ros::init(argc,argv,\"talker_person\"); //2.创建 ROS 句柄 ros::NodeHandle nh; //3.创建发布者对象 //<>中是消息类别,这边就是我们自定义的Person类，而该类位于plumbing_pub_sub命名空间下 ros::Publisher pub = nh.advertise(\"chatter_person\",1000); //4.组织被发布的消息，编写发布逻辑并发布消息 plumbing_pub_sub::Person p; p.name = \"张三\"; p.age = 20; p.height = 1.75; ros::Rate r(1); while (ros::ok()) { pub.publish(p); p.age += 1; ROS_INFO(\"我叫:%s,今年%d岁,高%.2f米\", p.name.c_str(), p.age, p.height); r.sleep(); ros::spinOnce(); } return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part10/2.1.html":{"url":"part10/2.1.html","title":"10.2.1修改CMakeList.txt文件","keywords":"","body":"10.2.1修改CMakeList.txt文件 依照7小节的修改方法，增加add_executable与 target_link_libraries宏为如下： 还需增加add_dependencies宏，原来如下：修改为如下： 解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part10/2.2.html":{"url":"part10/2.2.html","title":"10.2.2编译运行结果如下：","keywords":"","body":"10.2.2编译运行结果如下： 运行结果分析 符合预期，但是当我们运行rosmsg show时，出现错误，结果如下 因为在该终端我们没有source ./devel/setup.bash， 当source ./devel/setup.bash后在执行rosmsg show时，结果就正常了如下所示 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part10/3.html":{"url":"part10/3.html","title":"10.3 订阅方实现","keywords":"","body":"10.3 订阅方实现 在src下右键新建demo_msg_sub.cpp文件代码如下：（详见注释） /* 需求: 订阅人的信息 */ #include \"ros/ros.h\" #include \"plumbing_pub_sub/Person.h\" void doPerson(const plumbing_pub_sub::Person::ConstPtr& person_p){ ROS_INFO(\"订阅的人信息:%s, %d, %.2f\", person_p->name.c_str(), person_p->age, person_p->height); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //1.初始化 ROS 节点 ros::init(argc,argv,\"listener_person\"); //2.创建 ROS 句柄 ros::NodeHandle nh; //3.创建订阅对象 ros::Subscriber sub = nh.subscribe(\"chatter_person\",10,doPerson); //4.回调函数中处理 person //5.ros::spin(); ros::spin(); return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part11/1.html":{"url":"part11/1.html","title":" 11.1 准备工作-vscode配置（ settings.json文件修改）","keywords":"","body":"11.自定义msg使用(Python) 11.1准备工作-vscode配置（ settings.json文件修改） 为了方便代码提示以及误抛异常，需要先配置 vscode，将前面生成的 python 文件路径配置进 settings.json 即对 \"python.autoComplete.extraPaths\": 增加如下路径 \"/home/rosnoetic/demo_service/devel/lib/python3/dist-packages/\" 即如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part11/2.html":{"url":"part11/2.html","title":"11.2 发布方实现","keywords":"","body":"11.2 发布方实现 在scripts文件夹下右键新建文件，这里命名为demo_msg_pub_p.py代码如下 #! /usr/bin/env python \"\"\" 发布方: 循环发送消息 \"\"\" import rospy from plumbing_pub_sub.msg import Person if __name__ == \"__main__\": #1.初始化 ROS 节点 rospy.init_node(\"talker_person_p\") #2.创建发布者对象 pub = rospy.Publisher(\"chatter_person\",Person,queue_size=10) #3.组织消息 p = Person() p.name = \"葫芦瓦\" p.age = 18 p.height = 0.75 #4.编写消息发布逻辑 rate = rospy.Rate(1) while not rospy.is_shutdown(): pub.publish(p) #发布消息 rate.sleep() #休眠 rospy.loginfo(\"姓名:%s, 年龄:%d, 身高:%.2f\",p.name, p.age, p.height) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part11/3.html":{"url":"part11/3.html","title":"11.3 订阅方实现","keywords":"","body":"11.3 订阅方实现 在scripts文件夹下右键新建文件，这里命名为demo_msg_sub_p.py代码如下 #! /usr/bin/env python \"\"\" 订阅方: 订阅消息 \"\"\" import rospy from plumbing_pub_sub.msg import Person def doPerson(p): rospy.loginfo(\"接收到的人的信息:%s, %d, %.2f\",p.name, p.age, p.height) if __name__ == \"__main__\": #1.初始化节点 rospy.init_node(\"listener_person_p\") #2.创建订阅者对象 sub = rospy.Subscriber(\"chatter_person\",Person,doPerson,queue_size=10) rospy.spin() #4.循环 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/1.html":{"url":"part12/1.html","title":"12.1 服务通信自定义srv","keywords":"","body":"12.1 服务通信自定义srv 需求：服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/1.1.html":{"url":"part12/1.1.html","title":"12.1.1 srv文件创建与代码编写","keywords":"","body":"12.1.1 srv文件创建与代码编写 在前面的项目空间下，首先新建功能包plumbing_server_client添加依赖roscpp rospy std_msgs后，新建文件夹srv，在文件夹下新建文件Addints.srv 代码如下： # 客户端请求时发送的两个数字 int32 num1 int32 num2 --- #分割请求与响应 # 服务器响应发送的数据 int32 sum Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/1.2.html":{"url":"part12/1.2.html","title":"12.1.2 编辑配置文件","keywords":"","body":"12.1.2编辑配置文件 package.xml中添加编译依赖与执行依赖 message_generation message_runtime CMakeLists.txt编辑 srv 相关配置（参考9.3小节）1、find_package宏加入message_generation find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) # 需要加入 message_generation,必须有 std_msgs 2、 add_service_files宏加入AddInts.srv add_service_files( FILES AddInts.srv ) 3、generate_messages添加std_msgs依赖，一般情况写好了，直接取消注释就行 generate_messages( DEPENDENCIES std_msgs ) 4、catkin_package修改原本如下： catkin_package( # INCLUDE_DIRS include # LIBRARIES plumbing_server_client # CATKIN_DEPENDS roscpp rospy std_msgs # DEPENDS system_lib ) 修改为如下： Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/1.3.html":{"url":"part12/1.3.html","title":"12.1.3 编译产生中间文件","keywords":"","body":"12.1.3编译产生中间文件 C++ 需要调用的中间文件(.../工作空间/devel/include/包名/xxx.h) Python 需要调用的中间文件(.../工作空间/devel/lib/python3/dist-packages/包名/srv) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.html":{"url":"part12/2.html","title":"12.2 服务通信自定义srv调用(C++)","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.1.html":{"url":"part12/2.1.html","title":"12.2.1 准备工作--vscode配置","keywords":"","body":"12.2 服务通信自定义srv调用(C++) 12.2.1 准备工作--vscode配置 对c_cpp_properties.json的\"includePath\"添加12.1.3中的C++ 的总价两文件的路径，与之前一样，只需要写到include/**就可以，由于之前的话题通讯实例操作已经添加所以这边就不再重复添加了. Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.2.html":{"url":"part12/2.2.html","title":"12.2.2 服务器端编写","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.2.1.html":{"url":"part12/2.2.1.html","title":"12.02.2.1文件创建于代码编写","keywords":"","body":"12.2.2服务器端编写 12.2.2.1文件创建于代码编写 在src目录下新建demo01_server.cpp，代码编写如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" //回调函数，处理成功返回True bool doNums(plumbing_server_client::Addints::Request &request , plumbing_server_client::Addints::Response &response ){ //1/处理请求 int num1=request.num1; int num2=request.num2; ROS_INFO(\"收到的请求数据:num1=%d,num2=%d\",num1,num2); //2组织响应 int sum=num1+num2; response.sum=sum; ROS_INFO(\"处理的结果为:sum=%d\",sum); //在程序执行出错是会自动返回false，如求商，但分母是0的情况 return true;//没有这句编译也会通过，但会导致执行时无法停下回调函数，一直执行，且前面的接收等也会出错。 } int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"Addints_Server\"); ros::NodeHandle nh; //实例化服务器端 //<>参数省略不写，会根据传递进来的消息自动推导，并且使用rosservice info 时也能推导出符合的消息类型，但是要是传递的消息不符合要求，在回调函数调用成员变量时会出错 ros::ServiceServer server =nh.advertiseService(\"addInts\",doNums); ros::spin(); } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.2.2.html":{"url":"part12/2.2.2.html","title":"12.2.2.2 CMakeLists.txt配置","keywords":"","body":"12.2.2.2 CMakeLists.txt配置 参考10.2.1小节 add_executable项 add_executable(demo01_server_node src/demo01_server.cpp) target_link_libraries项 target_link_libraries(demo01_server_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_server_node ${PROJECT_NAME}_gencpp ) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.2.3.html":{"url":"part12/2.2.3.html","title":"12.2.2.3 编译运行","keywords":"","body":"12.2.2.3编译运行 结果如下: Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.3.html":{"url":"part12/2.3.html","title":"12.2.3 客户端编写","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.3.1.html":{"url":"part12/2.3.1.html","title":"12.2.3.1 文件创建于代码编写","keywords":"","body":"12.2.3客户端编写 12.2.3.1文件创建于代码编写 在src目录下右键新建文件，这里命名为demo01_client.cpp 代码如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"Addints_Client\"); ros::NodeHandle nh; //实例化客户端 //<>中为传递的srv数据类 这里是plumbing_server_client命名空间下的Addints ros::ServiceClient client =nh.serviceClient(\"addInts\"); //实例化srv对象 plumbing_server_client::Addints add_srv_1; //对实例化的对象写入数据 add_srv_1.request.num1=100; add_srv_1.request.num2=10; //使用call向client对应的服务器发生请求,并从服务器的回调函数返回标志位，通过写进去的response类型指针，获得回调函数处理结果 bool flag=client.call(add_srv_1); if (flag==true) { ROS_INFO(\"处理成功\"); ROS_INFO(\"client向服务器发生请求后处理返回的结果为:sum=%d\",add_srv_1.response.sum); } else{ ROS_INFO(\"处理失败\"); } } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.3.2.html":{"url":"part12/2.3.2.html","title":"12.2.3.2 CMakeLists.txt配置","keywords":"","body":"12.2.3.2CMakeLists.txt配置 参考12.2.3小节 add_executable项 add_executable(demo01_client_node src/demo01_client.cpp) target_link_libraries项 target_link_libraries(demo01_client_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_client_node ${PROJECT_NAME}_gencpp ) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.3.3.html":{"url":"part12/2.3.3.html","title":"12.2.3.3 编译运行","keywords":"","body":"12.2.3.3编译运行 结果如下: 注意需要先启动服务器端，如果先启动客户端，那么会导致运行失败 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.4.html":{"url":"part12/2.4.html","title":"12.2.4 客户端优化","keywords":"","body":"12.2.4客户端优化 需求优化为可以从键盘接收数据，作为num1与num2发送给服务器处理。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.4.1.html":{"url":"part12/2.4.1.html","title":"12.2.4.1 代码编写","keywords":"","body":"12.2.4.1代码编写 在src下新建文件demo01_client_optimize.cpp作为优化的客户端的文件。 代码如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" //与demo01_client相比实现参数动态输入 //argc 输入的参数数目 ，在这里我们要实现rosrun 包名 c++节点名 xx(num1,参数一) xx(num2,参数二)一共三个参数（c++节点名,参数一，参数二） //argv就是储存3个参数 int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); if(argc!=3) { ROS_INFO(\"未输入num1与num2值，将使用默认参数计算\"); } ros::init(argc,argv,\"Addints_Client_Optimize\");//注意节点名不要重复 ros::NodeHandle nh; //实例化客户端 //<>中为传递的srv数据类 这里是plumbing_server_client命名空间下的Addints ros::ServiceClient client =nh.serviceClient(\"addInts\"); //实例化srv对象 plumbing_server_client::Addints add_srv_1; //对实例化的对象写入数据 if(argc!=3){ add_srv_1.request.num1=100; add_srv_1.request.num2=10; } else{ add_srv_1.request.num1=atoi(argv[1]);//atoi char型转为int型 add_srv_1.request.num2=atoi(argv[2]); ROS_INFO(\"请求为数据:num1=%d,num2=%d\",add_srv_1.request.num1,add_srv_1.request.num2); } //这是一个阻塞式函数，只有服务启动成功后才会继续执行，放在发生请求call之前 或者ros::service::waitForService(\"addInts\"); client.waitForExistence(); //使用call向client对应的服务器发生请求,并从服务器的回调函数返回标志位，通过写进去的response类型指针，获得回调函数处理结果 bool flag=client.call(add_srv_1); if (flag==true) { ROS_INFO(\"处理成功\"); ROS_INFO(\"client向服务器发生请求后处理返回的结果为:sum=%d\",add_srv_1.response.sum); } else{ //不要写else if(flag==false)处理失败不一定是false ROS_INFO(\"处理失败\"); } } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.4.2.html":{"url":"part12/2.4.2.html","title":"12.2.4.2 CMakeLists.txt配置","keywords":"","body":"CMakeLists.txt配置 参考12.3.2小节 add_executable项 add_executable(demo01_client_optimize_node src/demo01_client_optimize.cpp) target_link_libraries项 target_link_libraries(demo01_client_optimize_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_client_optimize_node ${PROJECT_NAME}_gencpp ) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/2.4.3.html":{"url":"part12/2.4.3.html","title":"12.2.4.3 编译运行","keywords":"","body":"12.2.4.3编译运行 结果如下： 并且由于 client.waitForExistence(); 语句。 此时可以先启动客户端，会显示等待信息， waitForService: Service [/addInts] is now available. 等待服务器启动.，而不会直接抛出异常。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.html":{"url":"part12/3.html","title":"12.3 服务通信自定义srv调用(Python)","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.1.html":{"url":"part12/3.1.html","title":"12.3.1 准备工作--vscode配置","keywords":"","body":"12.3服务通信自定义srv调用(Python) 12.3.1准备工作--vscode配置 需要像之前自定义 msg 实现一样配置settings.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同: { \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", ] } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.2.html":{"url":"part12/3.2.html","title":"12.3.2 服务器端编写","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.2.1.html":{"url":"part12/3.2.1.html","title":"12.3.2.1 文件创建与代码编写","keywords":"","body":"12.3.2服务器端编写 12.3.2.1文件创建与代码编写 在功能包plumbing_server_client文件夹下新建文件夹scripts，在该文件夹下新建服务器代码文件，这里我们命名为命名为demo01_server_p.py。代码如下： #! /usr/bin/env python import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 #from plumbing_server_client.srv import * #直接这样就导入全部包，但是这边不知道为什么出问题了，这样导入不行 def doNum(request): num1=request.num1 num2=request.num2 rospy.loginfo(\"服务器端接受的数据:num1 = %d, num2 = %d\",request.num1, request.num2) sum=num1+num2 #创建一个响应对象 response=AddintsResponse() response.sum=sum rospy.loginfo(\"服务器端接处理的结果为:sum = %d\",response.sum) return response if __name__ == \"__main__\":#注意这边是__不是_ rospy.init_node(\"Addints_Server_p\") server=rospy.Service(\"AddInts_p\",Addints,doNum) rospy.loginfo(\"服务器已经启动了\") rospy.spin() Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.2.2.html":{"url":"part12/3.2.2.html","title":"12.3.2.2 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.2.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/ddemo01_server_p.py 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.3.html":{"url":"part12/3.3.html","title":"12.3.3客户端编写","keywords":"","body":"Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.3.1.html":{"url":"part12/3.3.1.html","title":"12.3.3.1 文件创建与代码编写","keywords":"","body":"12.3.3客户端编写 12.3.3.1文件创建与代码编写 在scripts文件夹下新建客户端代码文件，这里我们命名为命名为demo01_server_p.py。代码如下： import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 if __name__ == \"__main__\":#注意这边是__不是_ rospy.init_node(\"Addints_Client_p\") client=rospy.ServiceProxy(\"AddInts_p\",Addints) rospy.loginfo(\"客户端已经启动了\") response=client.call(12,34) #或者 #response=client.call(num1=12,num2=34) rospy.loginfo(\"服务器返回的处理结果为%d\",response.sum) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.3.2.html":{"url":"part12/3.3.2.html","title":"12.3.3.1 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.3.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/ddemo01_client_p.py 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.4.html":{"url":"part12/3.4.html","title":"12.3.4 客户端优化","keywords":"","body":"12.3.4客户端优化 需求优化为可以从键盘接收数据，作为num1与num2发送给服务器处 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.4.1.html":{"url":"part12/3.4.1.html","title":"12.3.4.1 代码编写","keywords":"","body":"12.3.4.1代码编写 在scripts文件夹下新建文件demo01_client_optimize_p.py #1.导包 import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 import sys if __name__ == \"__main__\": #优化实现 if len(sys.argv) != 3: rospy.logerr(\"请正确提交参数\") sys.exit(1) # 2.初始化 ROS 节点 rospy.init_node(\"AddInts_Client_p_optimize\") # 3.创建请求对象 client = rospy.ServiceProxy(\"AddInts_p\",Addints) # 请求前，等待服务已经就绪 # 方式1: # rospy.wait_for_service(\"AddInts\") # 方式2 client.wait_for_service() # 4.发送请求,接收并处理响应 # 方式1 # resp = client(3,4) # 方式2 # resp = client(AddIntsRequest(1,5)) # 方式3 req = AddintsRequest() # req.num1 = 100 # req.num2 = 200 #优化 req.num1 = int(sys.argv[1]) req.num2 = int(sys.argv[2]) resp = client.call(req) #上面的四句话可以用下面的代替 num1=int(sys.argv[1]) num2=int(sys.argv[2]) resp = client.call(num1,num2) rospy.loginfo(\"响应结果:%d\",resp.sum) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part12/3.4.2.html":{"url":"part12/3.4.2.html","title":"12.3.4.1 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.4.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/demo01_client_optimize_p.py 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/1.1.html":{"url":"part13/1.1.html","title":"13.1.1代码编辑","keywords":"","body":"13.参数服务器 13.1参数增加与修改(C++) 13.1.1代码编辑 新建功能包plumbing_param_server，在src下新建cpp文件demo01_param_set.cpp。代码如下: /*实现新增与修改参数 需求：首先设置机器人的共享参数，类型，半径(0.15m), 再修改半径(0.2m) 实现 ：在 roscpp 中提供了两套 API 实现参数操作 ros::NodeHandle setParam(\"键\",值) ros::param set(\"键\",\"值\") */ #include \"ros/ros.h\" int main(int argc,char*argv[]) { ros::init(argc,argv,\"set_param_c\"); ros::NodeHandle nh; //参数新增 //方案一 nh.setParam(\"type\",\"xiaoHuang\"); nh.setParam(\"radious\",0.15); //方案二 ros::param::set(\"type_param\",\"xiaoBai\"); ros::param::set(\"radious_param\",0.15); //参数修改 //参数的重写就会覆盖原有值，就是修改 nh.setParam(\"radious\",0.2); ros::param::set(\"radious_param\",0.25); } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/1.2.html":{"url":"part13/1.2.html","title":"13.1.2 修改CMakeList.txt文件,编译运行","keywords":"","body":"13.1.2 修改CMakeList.txt文件 add_executable(demo01_param_set_node src/demo01_param_set.cpp) target_link_libraries(demo01_param_set_node ${catkin_LIBRARIES} ) 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/2.1.html":{"url":"part13/2.1.html","title":"13.2.1 代码编辑","keywords":"","body":"13.2参数查找(C++) 13.2.1代码编辑 代码如下: /* 参数服务器操作之查询_C++实现: 在 roscpp 中提供了两套 API 实现参数操作 ros::NodeHandle param(键,默认值) 存在，返回对应结果，否则返回默认值 getParam(键,存储结果的变量) 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamCached键,存储结果的变量)--提高变量获取效率 存在,返回 true,且将值赋值给参数2 若果键不存在，那么返回值为 false，且不为参数2赋值 getParamNames(std::vector) 获取所有的键,并存储在参数 vector 中 hasParam(键) 是否包含某个键，存在返回 true，否则返回 false searchParam(参数1，参数2) 搜索键，参数1是被搜索的键，参数2存储搜索结果的变量 ros::param ----- 与 NodeHandle 类似 */ include \"ros/ros.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"get_param_c\"); //NodeHandle-------------------------------------------------------- ros::NodeHandle nh; //param 函数 double res1 = nh.param(\"radious\",0.5); // 键存在，参数二为默认值，这个默认值的类型要与radious的类型一致 double res2 = nh.param(\"radiousxxxx\",0.5); // 键不存在,返回默认值0.5,这个默认值的类型要与radious的类型一致 ROS_INFO(\"param获取结果:%.2f,%.2f\",res1,res2); //getParam 函数 double nh_double_value; bool result = nh.getParam(\"radious\",nh_double_value); if(result){ ROS_INFO(\"获取的半径是：%.2f\",nh_double_value); } else{ ROS_INFO(\"被查询的参数不存在\"); } //getParamCached() 先看之前获取过吗，如果有则从缓存查询，提高变量获取效率，提升性能 nh.getParamCached(\"radious\",nh_double_value); ROS_INFO(\"通过缓存获取数据:%.2f\",nh_double_value); //getParamNames() std::vector param_names1; nh.getParamNames(param_names1); for (auto &&name : param_names1) { ROS_INFO(\"名称解析name = %s\",name.c_str()); } ROS_INFO(\"----------------------------\"); // hasParam(键) // 是否包含某个键，存在返回 true，否则返回 false ROS_INFO(\"存在 radious 吗? %d\",nh.hasParam(\"radious\")); ROS_INFO(\"存在 radiousxxxx 吗? %d\",nh.hasParam(\"radiousxxxx\")); // searchParam(参数1，参数2) // 搜索键，参数1是被搜索的键，参数2存储搜索结果的变量,这个结果是键名，也就是key值不是value值，不存在为空值 std::string key; nh.searchParam(\"radious\",key); ROS_INFO(\"搜索键:%s\",key.c_str()); //param-------------------------------------------------------- /* ROS_INFO(\"++++++++++++++++++++++++++++++++++++++++\"); int res3 = ros::param::param(\"param_int\",20); //存在 int res4 = ros::param::param(\"param_int2\",20); // 不存在返回默认 ROS_INFO(\"param获取结果:%d,%d\",res3,res4); // getParam 函数 int param_int_value; double param_double_value; bool param_bool_value; std::string param_string_value; std::vector param_stus; std::map param_friends; ros::param::get(\"param_int\",param_int_value); ros::param::get(\"param_double\",param_double_value); ros::param::get(\"param_bool\",param_bool_value); ros::param::get(\"param_string\",param_string_value); ros::param::get(\"param_vector\",param_stus); ros::param::get(\"param_map\",param_friends); ROS_INFO(\"getParam获取的结果:%d,%.2f,%s,%d\", param_int_value, param_double_value, param_string_value.c_str(), param_bool_value ); for (auto &&stu : param_stus) { ROS_INFO(\"stus 元素:%s\",stu.c_str()); } for (auto &&f : param_friends) { ROS_INFO(\"map 元素:%s = %s\",f.first.c_str(), f.second.c_str()); } // getParamCached() ros::param::getCached(\"param_int\",param_int_value); ROS_INFO(\"通过缓存获取数据:%d\",param_int_value); //getParamNames() std::vector param_names2; ros::param::getParamNames(param_names2); for (auto &&name : param_names2) { ROS_INFO(\"名称解析name = %s\",name.c_str()); } ROS_INFO(\"----------------------------\"); ROS_INFO(\"存在 param_int 吗? %d\",ros::param::has(\"param_int\")); ROS_INFO(\"存在 param_intttt 吗? %d\",ros::param::has(\"param_intttt\")); std::string key; ros::param::search(\"param_int\",key); ROS_INFO(\"搜索键:%s\",key.c_str()); */ return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/2.2.html":{"url":"part13/2.2.html","title":"13.2.2   修改CMakeList.txt文件,编译运行","keywords":"","body":"13.2.2修改CMakeList.txt文件 add_executable(demo01_param_get_node src/demo01_param_get.cpp) target_link_libraries(demo01_param_get_node ${catkin_LIBRARIES} ) 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/3.1.html":{"url":"part13/3.1.html","title":"13.3.1 代码编辑","keywords":"","body":"13.3参数删除(C++) 13.3.1代码编辑 /* 参数服务器操作之删除_C++实现: ros::NodeHandle deleteParam(\"键\") 根据键删除参数，删除成功，返回 true，否则(参数不存在)，返回 false ros::param del(\"键\") 根据键删除参数，删除成功，返回 true，否则(参数不存在)，返回 false */ #include \"ros/ros.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"delete_param_c\"); ros::NodeHandle nh; bool r1 = nh.deleteParam(\"radious\");//删除失败返回false ROS_INFO(\"radious 删除结果:%d\",r1); bool r2 = ros::param::del(\"radious_param\");//删除失败返回false ROS_INFO(\"radious_param 删除结果:%d\",r2); return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/3.2.html":{"url":"part13/3.2.html","title":"13.3.2 修改CMakeList.txt文件,编译运行","keywords":"","body":"13.3.2修改CMakeList.txt文件 add_executable(demo01_param_del_node src/demo01_param_del.cpp) target_link_libraries(demo01_param_del_node ${catkin_LIBRARIES} ) 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part13/4.html":{"url":"part13/4.html","title":"13.4 Python版不在赘述直接看原文档","keywords":"","body":"13.4 Python版不在赘述直接看原文档 http://www.autolabor.com.cn/book/ROSTutorials/di-2-zhang-ros-jia-gou-she-ji/24-can-shu-fu-wu-qi/233-can-shu-caozuo-b-python.html 链接如上。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part14/1.html":{"url":"part14/1.html","title":"14.1 确定通讯的话题和消息类型","keywords":"","body":"14.1 确定通讯的话题和消息类型 由于这边运动显示节点使用ROS自带的 turtlesim_node，所以需要了解该话题与控制节点通讯的话题的和消息类型和具体格式，在后面自制控制节点时才能采用对应的话题和消息类型和具体格式。 1.使用 rosrun turtlesim turtlesim_node rosrun turtlesim turtle_teleop_key 命令运行小乌龟程序后 通过计算图查看话题，启动计算图: rqt_graph 或者通过 rostopic 列出话题: rostopic list 确定话题为/turtle1/cmd_vel 2.对/turtle1/cmd_vel使用 rostopic info 命令获得消息类型为 Type: geometry_msgs/Twist 从此处可知话题所在的功能包为geometry_msgs，这个功能包应该在创建功能包添加依赖时加入，消息类型为Twist，则在编写C++时应include \"geometry_msgs/Twist.h\",编写Python时from geometry_msgs.msg import Twist 3.对geometry_msgs/Twist使用命令 rosmsg show 确定消息具体格式如下 geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z geometry_msgs/Vector3 是运行个方向的线速度，这边对于小乌龟来说只有X轴的线速度，即只有前进或后退的速度，不能沿Y轴的平移或者在立体空间下沿Z轴的高度方向的移动(这边的XYZ轴是固化于小乌龟自身的，比如沿小乌龟头部到尾部的圣体中轴线是X轴) geometry_msgs/Vector3是围绕上面XYZ各轴的角速度，单位rad/s，对于小乌龟只有绕Z轴的速度，产生偏航角 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part14/2.1.html":{"url":"part14/2.1.html","title":"14.2.1 代码实现","keywords":"","body":"14.2实现发布节点（C++） 14.2.1代码实现 创建功能包需要依赖的功能包: roscpp rospy std_msgs geometry_msgs 创建功能包plumbing_test 在src下创建源文件test_01_pub_twist.cpp 代码如下: /* 编写 ROS 节点，控制小乌龟画圆 准备工作: 1.获取topic(已知: /turtle1/cmd_vel) 2.获取消息类型(已知: geometry_msgs/Twist) 3.运行前，注意先启动 turtlesim_node 节点 实现流程: 1.包含头文件 2.初始化 ROS 节点 3.创建发布者对象 4.循环发布运动控制消息 */ #include \"ros/ros.h\" #include \"geometry_msgs/Twist.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); // 2.初始化 ROS 节点 ros::init(argc,argv,\"control\"); ros::NodeHandle nh; // 3.创建发布者对象 ros::Publisher pub = nh.advertise(\"/turtle1/cmd_vel\",1000); // 4.循环发布运动控制消息 //4-1.组织消息 geometry_msgs::Twist msg; msg.linear.x = 1.0; msg.linear.y = 0.0; msg.linear.z = 0.0; msg.angular.x = 0.0; msg.angular.y = 0.0; msg.angular.z = 2.0; //4-2.设置发送频率 ros::Rate r(10); //4-3.循环发送 while (ros::ok()) { pub.publish(msg); ros::spinOnce(); } return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part14/2.2.html":{"url":"part14/2.2.html","title":"14.2.2 修改CMakeList.txt文件,编译运行","keywords":"","body":"14.2.2 修改CMakeList.txt文件 add_executable(test_01_pub_twist_node src/test_01_pub_twist.cpp) target_link_libraries(test_01_pub_twist_node ${catkin_LIBRARIES} ) 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part14/3.1.html":{"url":"part14/3.1.html","title":" 14.3.1代码编辑","keywords":"","body":"14.3实现发布节点（Python） 14.3.1代码编辑 新建scripts文件夹，在其下新建 test_01_pub_twist_p.py 代码如下: #! /usr/bin/env python \"\"\" 编写 ROS 节点，控制小乌龟画圆 准备工作: 1.获取topic(已知: /turtle1/cmd_vel) 2.获取消息类型(已知: geometry_msgs/Twist) 3.运行前，注意先启动 turtlesim_node 节点 实现流程: 1.导包 2.初始化 ROS 节点 3.创建发布者对象 4.循环发布运动控制消息 \"\"\" import rospy from geometry_msgs.msg import Twist if __name__ == \"__main__\": # 2.初始化 ROS 节点 rospy.init_node(\"control_circle_p\") # 3.创建发布者对象 pub = rospy.Publisher(\"/turtle1/cmd_vel\",Twist,queue_size=1000) # 4.循环发布运动控制消息 rate = rospy.Rate(10) msg = Twist() msg.linear.x = 1.0 msg.linear.y = 0.0 msg.linear.z = 0.0 msg.angular.x = 0.0 msg.angular.y = 0.0 msg.angular.z = 0.5 while not rospy.is_shutdown(): pub.publish(msg) rate.sleep() Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part14/3.2.html":{"url":"part14/3.2.html","title":"14.3.2修改CMakeList.txt文件,添加可执行权限,编译运行","keywords":"","body":"14.3.2修改CMakeList.txt文件 catkin_install_python(PROGRAMS scripts/test_01_pub_twist_p.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part15/1.html":{"url":"part15/1.html","title":"15.Topic通讯案例--小乌龟位姿的获取(话题订阅)","keywords":"","body":"15.Topic通讯案例--小乌龟位姿的获取(话题订阅) 15.1确定通讯的话题和消息类型 确定了通讯的话题是 /turtle1/pose 消息类型是 turtlesim/Pose 消息格式是 ​float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part15/2.1.html":{"url":"part15/2.1.html","title":"15.2.1添加依赖功能包","keywords":"","body":"15.2实现订阅节点(C++) 15.2.1添加依赖功能包 功能包需要依赖的功能包: roscpp rospy std_msgs turtlesim 由于功能包已经创建了所以需要手动添加功能包turtlesim 在package.xml文件添加 turtlesim turtlesim 在CMakelists.txt文件对find_package添加 turtlesim Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part15/2.2.html":{"url":"part15/2.2.html","title":"15.2.2代码编写","keywords":"","body":"15.2.2代码编写 新建test_01_pub_twist.cpp文件 代码如下 /* 订阅小乌龟的位姿: 时时获取小乌龟在窗体中的坐标并打印 准备工作: 1.获取话题名称 /turtle1/pose 2.获取消息类型 turtlesim/Pose 3.运行前启动 turtlesim_node 与 turtle_teleop_key 节点 实现流程: 1.包含头文件 2.初始化 ROS 节点 3.创建 ROS 句柄 4.创建订阅者对象 5.回调函数处理订阅的数据 6.spin */ #include \"ros/ros.h\" #include \"turtlesim/Pose.h\" void doPose(const turtlesim::Pose::ConstPtr& p){ ROS_INFO(\"乌龟位姿信息:x=%.2f,y=%.2f,theta=%.2f,lv=%.2f,av=%.2f\", p->x,p->y,p->theta,p->linear_velocity,p->angular_velocity ); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); // 2.初始化 ROS 节点 ros::init(argc,argv,\"sub_pose\"); // 3.创建 ROS 句柄 ros::NodeHandle nh; // 4.创建订阅者对象 ros::Subscriber sub = nh.subscribe(\"/turtle1/pose\",1000,doPose); // 5.回调函数处理订阅的数据 // 6.spin ros::spin(); return 0; } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part15/2.3.html":{"url":"part15/2.3.html","title":"15.2.3 修改CMakeLists.txt文件,编译运行","keywords":"","body":"15.2.3 修改CMakeLists.txt文件 add_executable(test_01_sub_pose_node src/test_01_sub_pose.cpp) target_link_libraries(test_01_sub_pose_node ${catkin_LIBRARIES} ) 编译运行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part15/3.html":{"url":"part15/3.html","title":"15.3实现订阅节点（Python）","keywords":"","body":"15.3实现订阅节点（Python） 不在赘述直接看文档 http://www.autolabor.com.cn/book/ROSTutorials/di-2-zhang-ros-jia-gou-she-ji/25-tong-xin-ji-zhi-shi-cao/252-shi-cao-02-hua-ti-ding-yue.html 连接如上。 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part16/readme.html":{"url":"part16/readme.html","title":"16.服务调用案例--添加小乌龟","keywords":"","body":"16.服务调用案例--添加小乌龟 不在赘述直接看文档，对应程序里的test_03_xxxxxx. Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part17/readme.html":{"url":"part17/readme.html","title":"17.参数设置案例--设置小乌龟背景颜色","keywords":"","body":"17.参数设置案例--设置小乌龟背景颜色 不在赘述直接看文档，对应程序里的test_04_param 只是记得参数设置完需要重启小乌龟哦节点生效， Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part18/readme.html":{"url":"part18/readme.html","title":"18.通讯机制比较","keywords":"","body":"18.通讯机制比较 话题通讯异步的含义是:当一个msg发过来后，可能还没处理，后续的msg就有发过来了，也就是不用等待当前的msg处理完，在接受下一个msg，这样可能会错失消息，对应的处理办法就是设置缓存区，将没来得及处理的消息放置在缓存区 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/1.1.html":{"url":"part19/1.1.html","title":"19.1.1 初始化","keywords":"","body":"19.通讯机制进阶 19.1 常用API 19.1.1初始化 /** @brief ROS初始化函数。 * 该函数可以解析并使用节点启动时传入的参数(通过参数设置节点名称、命名空间...) * 该函数有多个重载版本，如果使用NodeHandle建议调用该版本。 * \\param argc 参数个数 \\param argv 参数列表，可以通过命令行传参，格式为 _参数名:=参数值,这个值除了能在argv中调用，还会设置为param参数服务器的参数 \\param name 节点名称，需要保证其唯一性，不允许包含命名空间，当一个节点重复启动时，之前启动的会被关闭。有些特定场景需要节点多次启动，那么就需要下面的options参数，具体为ros::init_options，使用时,ros::init(argc,argv,\"xxx\",ros::init_options::AnonymousName)会在用户自定义的name后面添加后缀 \\param options 节点启动选项，被封装进了ros::init_options，使用时,ros::init(argc,argv,\"xxx\",ros::init_options::参数值) / void init(int &argc, char **argv, const std::string& name, uint32_t options = 0); Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/1.2.html":{"url":"part19/1.2.html","title":"19.1.2 话题与服务相关对象","keywords":"","body":"19.1.2话题与服务相关对象 /** * \\brief 根据话题生成发布对象 * * 在 ROS master 注册并返回一个发布者对象，该对象可以发布消息 * * 使用示例如下: * * ros::Publisher pub = handle.advertise(\"my_topic\", 1); * * \\param topic 发布消息使用的话题 * * \\param queue_size 等待发送给订阅者的最大消息数量 * * \\param latch (optional) 如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者连接时会将该消息发送给订阅者，可以用于导航时，将其设置为true，先发送一遍地图（此时可以无订阅者），当订阅者链接时，自动将这个地图发布给订阅者 * * \\return 调用成功时，会返回一个发布对象 * * */ template Publisher advertise(const std::string& topic, uint32_t queue_size, bool latch = false) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/1.3.html":{"url":"part19/1.3.html","title":"19.1.3 回旋函数","keywords":"","body":"19.1.3回旋函数 1.spinOnce() 只处理回调函数一次，后面的代码还能执行到，所以一般用于循环体内，或者在发送者中因为官方建议添加该句 /** * \\brief 处理一轮回调 * * 一般应用场景: * 在循环体内，处理所有可用的回调函数 * */ ROSCPP_DECL void spinOnce(); 2.spin() 后面的代码不能被执行 /** * \\brief 进入循环处理回调 */ ROSCPP_DECL void spin(); Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/1.4.html":{"url":"part19/1.4.html","title":"19.1.4 时间","keywords":"","body":"19.1.4 时间 1.时刻 ros::init(argc,argv,\"hello_time\"); ros::NodeHandle nh;//必须创建句柄，否则时间没有初始化，导致后续API调用失败 ros::Time right_now = ros::Time::now();//将当前时刻封装成对象 ROS_INFO(\"当前时刻:%.2f\",right_now.toSec());//获取距离 1970年01月01日 00:00:00 的秒数，浮点型 ROS_INFO(\"当前时刻:%d\",right_now.sec);//获取距离 1970年01月01日 00:00:00 的秒数，整型 ros::Time someTime(100,100000000);//构造一个时间对象，设置时间距离1970年01月01日 00:00:00 的时间 参数1:秒数 参数2:纳秒 两个参数相加的时间 ROS_INFO(\"时刻:%.2f\",someTime.toSec()); //100.10 ros::Time someTime2(100.3);//直接传入 double 类型的秒数 ROS_INFO(\"时刻:%.2f\",someTime2.toSec()); //100.30 2.持续时间 设置一个时间区间(间隔): ROS_INFO(\"当前时刻:%.2f\",ros::Time::now().toSec()); ros::Duration du(10);//持续10秒钟,参数是double类型的，以秒为单位 du.sleep();//持续10秒时间休眠 ROS_INFO(\"持续时间:%.2f\",du.toSec());//将持续时间换算成秒 ROS_INFO(\"当前时刻:%.2f\",ros::Time::now().toSec()); 3.持续时间与时刻的运算 ROS_INFO(\"时间运算\"); ros::Time now = ros::Time::now(); ros::Duration du1(10); ros::Duration du2(20); ROS_INFO(\"当前时刻:%.2f\",now.toSec()); //1.time 与 duration 运算 ros::Time after_now = now + du1; ros::Time before_now = now - du1; ROS_INFO(\"当前时刻之后:%.2f\",after_now.toSec()); ROS_INFO(\"当前时刻之前:%.2f\",before_now.toSec()); //2.duration 之间相互运算 ros::Duration du3 = du1 + du2; ros::Duration du4 = du1 - du2; ROS_INFO(\"du3 = %.2f\",du3.toSec()); ROS_INFO(\"du4 = %.2f\",du4.toSec()); //PS: time 与 time 不可以运算 // ros::Time nn = now + before_now;//异常 4.定时器 ros::NodeHandle nh;//必须创建句柄，否则时间没有初始化，导致后续API调用失败 // ROS 定时器 /** * \\brief 创建一个定时器，按照指定频率调用回调函数。 * * \\param period 时间间隔 * \\param callback 回调函数 * \\param oneshot 如果设置为 true,整个程序只执行一次回调函数，设置为 false,就每次到定时时间就执行。 * \\param autostart 如果为true，自动启动定时器，设置为 false，需要手动启动，默认是True */ //Timer createTimer(Duration period, const TimerCallback& callback, bool oneshot = false, // bool autostart = true) const; // ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing); ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing,true);//只执行一次 // ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing,false,false);//需要手动启动，启动方式，定时器名.start(); // timer.start(); ros::spin(); //必须 spin 定时器回调函数 void doSomeThing(const ros::TimerEvent &event){ ROS_INFO(\"-------------\"); ROS_INFO(\"event:%s\",std::to_string(event.current_real.toSec()).c_str());//打印函数被调用的时刻。 } Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/1.5.html":{"url":"part19/1.5.html","title":"19.1.5 其他函数","keywords":"","body":"19.1.5 其他函数 在发布实现时，一般会循环发布消息，循环的判断条件一般由节点状态来控制，C++中可以通过 ros::ok() 来判断节点状态是否正常，而 python 中则通过 rospy.is_shutdown() 来实现判断，导致节点退出的原因主要有如下几种: 节点接收到了关闭信息，比如常用的 ctrl + c 快捷键就是关闭节点的信号； 同名节点启动，导致现有节点退出； 程序中的其他部分调用了节点关闭相关的API(C++中是ros::shutdown()，python中是rospy.signal_shutdown()) 另外，日志相关的函数也是极其常用的，在ROS中日志被划分成如下级别: DEBUG(调试):只在调试时使用，此类消息不会输出到控制台； INFO(信息):标准消息，一般用于说明系统内正在执行的操作； WARN(警告):提醒一些异常情况，但程序仍然可以执行； ERROR(错误):提示错误信息，此类错误会影响程序运行； FATAL(严重错误):此类错误将阻止节点继续运行. 使用实例 rospy.logdebug(\"hello,debug\") #不会输出 rospy.loginfo(\"hello,info\") #默认白色字体 rospy.logwarn(\"hello,warn\") #默认黄色字体 rospy.logerr(\"hello,error\") #默认红色字体 rospy.logfatal(\"hello,fatal\") #默认红色字体 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/2.1.html":{"url":"part19/2.1.html","title":"19.2.1 自定义头文件调用","keywords":"","body":"19.2 ROS的头文件与源文件 19.2.1自定义头文件调用 1.头文件 新建功能包plumbing_head，在功能包下的 include/功能包名 目录下新建头文件: hello.h，示例内容如下: #ifndef _HELLO_H #define _HELLO_H namespace hello_ns{ class HelloPub { public: void run(); }; } #endif 2.修改.vscode 下 c_cpp_properties.json 对includepath属性添加 \"/home/用户/工作空间/src/功能包/include/**\" 注意与自定义msg时添加产生的中间文件的路径相区分开，那个是在devel文件夹下，结果如下 3.可执行文件(CPP文件) 在 src 目录下新建文件:hello.cpp，示例内容如下: #include \"ros/ros.h\" #include \"test_head/hello.h\" namespace hello_ns { void HelloPub::run(){ ROS_INFO(\"自定义头文件的使用....\"); } } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"test_head_node\"); hello_ns::HelloPub helloPub; helloPub.run(); return 0; } 4.配置CMakeLists.txt文件 头文件相关配置如下: include_directories( include ${catkin_INCLUDE_DIRS} ) 可执行配置文件配置方式与之前一致: add_executable(hello src/hello.cpp) add_dependencies(hello ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(hello ${catkin_LIBRARIES} ) Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/2.2.html":{"url":"part19/2.2.html","title":"19.2.2 自定义源文件调用(头文件的函数在对应CPP文件中实现)","keywords":"","body":"19.2.2自定义源文件调用(头文件的函数在对应CPP文件中实现) 与19.2.1相比需要 配置CMakeLists.txt文件使头文件与对应的cpp文件链接起来。 1.头文件 新建功能包plumbing_head_src ， 在功能包下的 include/功能包名 目录下新建头文件: helllo.h，示例内容如下: #ifndef _HAHA_H #define _HAHA_H namespace hello_ns { class My { public: void run(); }; } #endif 2.配置 c_cpp_properties.json文件 \"/home/用户/工作空间/src/功能包/include/**\" 3.源文件 #include \"plumbing_head_src/hello.h\" #include \"ros/ros.h\" namespace hello_ns{ void Myhello::run(){ ROS_INFO(\"源文件中的run 函数运行\"); } } 4.可执行文件 在 src 目录下新建文件: use_hello.cpp，示例内容如下: #include \"ros/ros.h\" #include \"plumbing_head_src/hello.h\" int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"hello_head_src\"); hello_ns::Myhello myhello; myhello.run(); } 5.配置CMakeLists.txt文件（可以与自定义msg中的配置相比较学习） 头文件与源文件相关配置: include_directories( include ${catkin_INCLUDE_DIRS} ) # Declare a C++ library add_library(head_src#库的名字 #include/plumbing_head_src/hello.h include/${PROJECT_NAME}/hello.h#与上面结果一致，${PROJECT_NAME}是取功能包名 src/hello.cpp ) add_dependencies(head_src ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(head ${catkin_LIBRARIES} ) 可执行文件配置: add_executable(use_hello_node src/use_hello.cpp) add_dependencies(use_hello_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) target_link_libraries(use_hello_node head_src#添加的库的名字 ${catkin_LIBRARIES} ) 这边突然出现很奇怪的错误，可能是 add_dependencies(use_hello_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) 需要放在 add_dependencies(head_src ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) 后面的原因 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part19/3.html":{"url":"part19/3.html","title":"19.3 Python模块的导入","keywords":"","body":"19.3 Python模块的导入 新建功能包plumbing_py_moudle 新建文件夹scripts，新建文件mytools.py代码如下 mynumxx=100 新建文件use_tools.py 代码如下 #1.导包 import os import sys import rospy path=os.path.abspath(\".\") #sys.path.insert(0,\"/home/rosnoetic/demo_service/src/plumbing_py_moudle/scripts\") sys.path.insert(0,path + \"/src/plumbing_py_moudle/scripts\") import mytools#一定要放在sys.path.insert后面 if __name__ == \"__main__\": #2.初始化 ROS 节点:命名(唯一) rospy.init_node(\"use_tools\") #rospy.loginfo(\"执行时参考的路径:%s\",path) rospy.loginfo(\"mynum=%d\",mytools.mynumxx) 添加执行权限，编辑CMakelists.txt文件后执行 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/1.html":{"url":"part20/1.html","title":"20.1 ROS元功能包","keywords":"","body":"20.ROS运行管理 20.1ROS元功能包 见视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.html":{"url":"part20/2.html","title":"20.2 ROS节点管理launch文件","keywords":"","body":"20.2ROS节点管理launch文件 新建launch01_basic功能包在文件夹新建start_turtle.launch Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.1.html":{"url":"part20/2.1.html","title":"20.2.1 launch文件标签之launch","keywords":"","body":"20.2.1 launch文件标签之launch 标签是所有 launch 文件的根标签，充当其他标签的容器 只有一个属性deprecated标签是所有 launch 文件的根标签，充当其他标签的容器用于声明文件已被启用 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.2.html":{"url":"part20/2.2.html","title":"20.2.2 launch文件标签之node","keywords":"","body":"20.2.2 launch文件标签之node 见视频与文档这边只说一点 ns=\"xxx\" (可选) 该属性用于设置节点所处命名空间，使用rosnode list查看节点时如果是XXXA/XXXB这种的前面的XXXA就是命名空间，一般用于节点命名重复的情况下使用 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.3.html":{"url":"part20/2.3.html","title":"20.2.3 launch文件标签之remap","keywords":"","body":"20.2.3 launch文件标签之remap 用于话题重命名 1.属性 from=\"xxx\" 原始话题名称 to=\"yyy\" 目标名称 案例：teleop_twist_keyboard.py是乌龟键盘控制节点 比turtle_teleop_key好使用，使用的话题是/cmd_vel向外发布消息 而乌龟GUI节点turtlesim_node节点的话题是/turtle1/cmd_vel，订阅消息，两者无法直接通讯需要对话题重命名 代码如下（注意第一个node对应的>处没有斜杠） 2.子级标签 无 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.4.html":{"url":"part20/2.4.html","title":"20.2.4 launch文件标签之param","keywords":"","body":"20.2.4 launch文件标签之param 标签主要用于在参数服务器上设置参数，参数源可以在标签中通过 value 指定，也可以通过外部文件加载，在标签中时，相当于私有命名空间。 name=\"命名空间/参数名\" 参数名称，可以包含命名空间 value=\"xxx\" (可选) 定义参数值，如果此处省略，必须指定外部文件作为参数源 type=\"str | int | double | bool | yaml\" (可选) 指定参数类型，如果未指定，roslaunch 会尝试确定参数类型，规则如下: 如果包含 '.' 的数字解析未浮点型，否则为整型 \"true\" 和 \"false\" 是 bool 值(不区分大小写)其他是字符串 代码如下 结果 可以看到param_B前面多了个命名空间 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.5.html":{"url":"part20/2.5.html","title":"20.2.5 launch文件标签之rosparam","keywords":"","body":"20.2.5 launch文件标签之rosparam 标签可以从 YAML 文件导入参数，或将参数导出到 YAML 文件，也可以用来删除参数，标签在标签中时被视为私有。 command=\"load | dump | delete\" (可选，默认 load) 加载、导出或删除参数 file=\"$(find xxxxx)/xxx/yyy....\" 加载或导出到的 yaml 文件 param=\"参数名称\" ns=\"命名空间\" (可选)1.参数的写入 代码如下: yaml文件代码如下: bg_R: 100 bg_G: 10 bg_B: 10 注意每个参数冒号后面要有空格结果如下 2.参数的导出使用dump命令导出，但是由于rosparam率先执行，下面的node标签才会执行，所以放在一个launch文件里可能会出现导出参数先于节点启动的情况，这样会导致导出的参数没有那些未启动的节点的参数，因此需要再新建一个launch文件存放导出命令，在节点启动完成之后在启动这个导出命令 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.6.html":{"url":"part20/2.6.html","title":"20.2.6 launch文件标签之group","keywords":"","body":"20.2.6 launch文件标签之group 标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间 这样可以在不同的group下面有同样的node名称 代码如下 结果如下 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/2.7.html":{"url":"part20/2.7.html","title":"20.2.7 launch文件标签之arg","keywords":"","body":"20.2.7 launch文件标签之arg 标签是用于动态传参，类似于函数的参数，可以增强launch文件的灵活性 如下多个param都一样，这可以这样： 可以通过命令行在执行launch文件时传参进行统一设置 roslaunch XX.launch xxx:=值 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/3.html":{"url":"part20/3.html","title":"20.3 ROS工作空间覆盖","keywords":"","body":"20.3 ROS工作空间覆盖 所谓工作空间覆盖，是指不同工作空间中，存在重名的功能包的情形。 ROS 开发中，会自定义工作空间且自定义工作空间可以同时存在多个，可能会出现一种情况: 虽然特定工作空间内的功能包不能重名，但是自定义工作空间的功能包与内置的功能包可以重名或者不同的自定义的工作空间中也可以出现重名的功能包，那么调用该名称功能包时，会调用哪一个呢？比如：自定义工作空间A存在功能包 turtlesim，自定义工作空间B也存在功能包 turtlesim，当然系统内置空间也存在turtlesim，如果调用turtlesim包，会调用哪个工作空间中的呢？ 重名之后ROS执行结果ROS 会解析 .bashrc 文件，并生成 ROS_PACKAGE_PATH ROS包路径，该变量中按照 .bashrc 中配置设置工作空间优先级，在设置时需要遵循一定的原则:ROS_PACKAGE_PATH 中的值，和 .bashrc 的配置顺序相反--->后配置的优先级更高 结论功能包重名时，会按照 ROS_PACKAGE_PATH 查找，配置在前的会优先执行隐患存在安全隐患，比如当前工作空间B优先级更高，意味着当程序调用 turtlesim 时，不会调用工作空间A也不会调用系统内置的 turtlesim，如果工作空间A在实现时有其他功能包依赖于自身的 turtlesim，而按照ROS工作空间覆盖的涉及原则，那么实际执行时将会调用工作空间B的turtlesim，从而导致执行异常，出现安全隐患。总的来说就是由于rosrun时是rosrun 包名 节点名 这个包名被调用成错误的包，就发生错误了 ROS暂时没有补救措施，应当注意出现这种情况 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/4.html":{"url":"part20/4.html","title":"20.4 ROS节点名称重名","keywords":"","body":"20.4 ROS节点名称重名 场景:ROS 中创建的节点是有名称的，C++初始化节点时通过API:ros::init(argc,argv,\"xxxx\");来定义节点名称，在Python中初始化节点则通过 rospy.init_node(\"yyyy\") 来定义节点名称。在ROS的网络拓扑中，是不可以出现重名的节点的，因为假设可以重名存在，那么调用时会产生混淆，这也就意味着，不可以启动重名节点或者同一个节点启动多次，的确，在ROS中如果启动重名节点的话，之前已经存在的节点会被直接关闭，但是如果有这种需求的话，怎么优化呢？ 在ROS中给出的解决策略是使用命名空间(加前缀)或名称重映射 命名空间就是为名称添加前缀，名称重映射是为名称起别名。这两种策略都可以解决节点重名问题，两种策略的实现途径有多种: rosrun 命令 launch 文件 编码实现 直接看视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/5.html":{"url":"part20/5.html","title":"20.5 ROS话题名称重名","keywords":"","body":"20.5 ROS话题名称重名 直接看视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/6.html":{"url":"part20/6.html","title":"20.6 ROS参数名称设置","keywords":"","body":"20.6 ROS参数名称设置 直接看视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part20/7.html":{"url":"part20/7.html","title":"20.7 ROS分布式通讯","keywords":"","body":"20.7 ROS分布式通讯 可以实现主机从机之间相互发布或订阅消息直接看视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part21/1.1.html":{"url":"part21/1.1.html","title":"21.1.1 坐标msg消息","keywords":"","body":"21.ROS常用组件 21.1 TF坐标变换 21.1.1 坐标msg消息 订阅发布模型中数据载体 msg 是一个重要实现，首先需要了解一下，在坐标转换实现中常用的 msg:geometry_msgs/TransformStamped和geometry_msgs/PointStamped 前者用于传输坐标系相关位置信息，后者用于传输某个坐标系内坐标点的信息。在坐标变换中，频繁的需要使用到坐标系的相对关系以及坐标点信息。 1.geometry_msgs/TransformStamped std_msgs/Header header #头信息 uint32 seq #|-- 序列号 time stamp #|-- 时间戳 string frame_id #|-- 坐标 ID string child_frame_id #子坐标系的 id geometry_msgs/Transform transform #坐标信息 geometry_msgs/Vector3 translation #偏移量 float64 x #|-- X 方向的偏移量 float64 y #|-- Y 方向的偏移量 float64 z #|-- Z 方向上的偏移量 geometry_msgs/Quaternion rotation #四元数 float64 x float64 y float64 z float64 w 四元数用于表示坐标的相对姿态 2.geometry_msgs/PointStamped std_msgs/Header header #头 uint32 seq #|-- 序号 time stamp #|-- 时间戳 string frame_id #|-- 所属坐标系的 id geometry_msgs/Point point #点坐标 float64 x #|-- x y z 坐标 float64 y float64 z Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part21/1.2.html":{"url":"part21/1.2.html","title":"21.1.2静态坐标变换","keywords":"","body":"21.1.2静态坐标变换 所谓静态坐标变换，是指两个坐标系之间的相对位置是固定的。需求描述:现有一机器人模型，核心构成包含主体与雷达，各对应一坐标系，坐标系的原点分别位于主体与雷达的物理中心，已知雷达原点相对于主体原点位移关系如下: x 0.2 y0.0 z0.5。当前雷达检测到一障碍物，在雷达坐标系中障碍物的坐标为 (2.0 3.0 5.0),请问，该障碍物相对于主体的坐标是多少？ 实现 工作空间demo_tf,功能包tf_01_static,添加的依赖 roscpp rospy std_msgs tf2 tf2_ros tf2_geometry_msgs geometry_msgs 代码(发布者demo02_static_sub.cpp): 发布两坐标相对关系: #include \"ros/ros.h\" #include \"tf2_ros/transform_listener.h\"//坐标转换的订阅者对象 #include \"tf2_ros/buffer.h\" #include \"geometry_msgs/PointStamped.h\"//用于传输某个坐标系内坐标点的信息 #include \"tf2_geometry_msgs/tf2_geometry_msgs.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"static_sub\"); ros::NodeHandle nh; //创建buffer缓存对象 tf2_ros::Buffer buffer; //创建监听者对象 可以将订阅的数据（两坐标系关系）存入buffer tf2_ros::TransformListener listenter(buffer); //实例化一个PS坐标 geometry_msgs::PointStamped ps; ps.header.frame_id=\"laser\";//雷达坐标系id ps.header.stamp=ros::Time::now(); //障碍物在雷达坐标系下的坐标 ps.point.x=2.0; ps.point.y=3.0; ps.point.z=5.0; ros::Rate rate(10); //ros::Duration(2).sleep();//延迟两秒，等待发布者的启动，将发布的转换关系发生红过来 while (ros::ok()) { try { geometry_msgs::PointStamped ps_out; ps_out=buffer.transform(ps,\"base_link\");//参数一 要转换的坐标 参数二 要转化为的目标坐标系 //这边必须保证转换关系已经订阅到，否则会报错找不到与base_link的关系，所以上面延迟两秒,或者是使用try ROS_INFO(\"转换后的坐标:(%.2f,%.2f,%.2f),参考的坐标系:%s\", ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id.c_str()); } catch(const std::exception& e) { //std::cerr buffer.transform时，必须保证转换关系已经订阅到，否则会报错 结果如下 则是一个广播的topic，无需设置具体topic，在订阅者代码使用相应的接收既可以或得 订阅者(demo02_static_sub.cpp获取相对关系后，使用相对关系将雷达上的坐标转化为小车坐标) #include \"ros/ros.h\" #include \"tf2_ros/transform_listener.h\"//坐标转换的订阅者对象 #include \"tf2_ros/buffer.h\" #include \"geometry_msgs/PointStamped.h\"//用于传输某个坐标系内坐标点的信息 #include \"tf2_geometry_msgs/tf2_geometry_msgs.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"static_sub\"); ros::NodeHandle nh; //创建buffer缓存对象 tf2_ros::Buffer buffer; //创建监听者对象 可以将订阅的数据（两坐标系关系）存入buffer tf2_ros::TransformListener listenter(buffer); //实例化一个PS坐标 geometry_msgs::PointStamped ps; ps.header.frame_id=\"laser\";//雷达坐标系id ps.header.stamp=ros::Time::now(); //障碍物在雷达坐标系下的坐标 ps.point.x=2.0; ps.point.y=3.0; ps.point.z=5.0; ros::Rate rate(10); //ros::Duration(2).sleep();//延迟两秒，等待发布者的启动，将发布的转换关系发生红过来 while (ros::ok()) { try { geometry_msgs::PointStamped ps_out; ps_out=buffer.transform(ps,\"base_link\");//参数一 要转换的坐标 参数二 要转化为的目标坐标系 //这边必须保证转换关系已经订阅到，否则会报错找不到与base_link的关系，所以上面延迟两秒,或者是使用try ROS_INFO(\"转换后的坐标:(%.2f,%.2f,%.2f),参考的坐标系:%s\", ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id.c_str()); } catch(const std::exception& e) { //std::cerr Python实现见视频 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part21/1.3.html":{"url":"part21/1.3.html","title":"21.1.3 实现多个静态坐标变换","keywords":"","body":"21.1.3 实现多个静态坐标变换 需求描述： 在20.1.2小节的基础上增加一个摄像头，使用同一个节点去发布转换关系 发布者（demo03_static_pub2.cpp） #include \"ros/ros.h\" #include \"tf2_ros/static_transform_broadcaster.h\"//坐标转换的发布者对象,以广播的形式发送 #include \"geometry_msgs/TransformStamped.h\"//坐标系相对关系的msg #include \"tf2/LinearMath/Quaternion.h\" //用于将欧拉角转换成四元数 int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"static_pub2\"); //创建发布对象 tf2_ros::StaticTransformBroadcaster pub; //组织被发布的消息 //创建坐标系信息 geometry_msgs::TransformStamped tfs; tfs.header.stamp=ros::Time::now(); //tfs.header.seq = 100; tfs.header.frame_id=\"base_link\";//相对坐标系中被参考的那个，案例里就是小车主体 tfs.child_frame_id=\"laser\";//子坐标系，这里是雷达 //偏移量设置 tfs.transform.translation.x=0.2; tfs.transform.translation.y=0.0; tfs.transform.translation.z=0.5; //四元数设置，需要根据欧拉角转换 tf2::Quaternion qtn; //向该对象设置欧拉角 这个对象可以将欧拉角转换成四元数 qtn.setRPY(0,0,0);//偏航角，俯仰角，翻滚角！！单位是弧度 tfs.transform.rotation.x=qtn.getX(); tfs.transform.rotation.y=qtn.getY(); tfs.transform.rotation.z=qtn.getZ(); tfs.transform.rotation.w=qtn.getW(); //----------------------- //创建坐标系信息 geometry_msgs::TransformStamped tfs2; tfs2.header.stamp=ros::Time::now(); //tfs.header.seq = 100; tfs2.header.frame_id=\"base_link\";//相对坐标系中被参考的那个，案例里就是小车主体 tfs2.child_frame_id=\"laser2\";//子坐标系，这里是摄像头 //偏移量设置 tfs2.transform.translation.x=1.0; tfs2.transform.translation.y=0.0; tfs2.transform.translation.z=0.5; //四元数设置，需要根据欧拉角转换 tf2::Quaternion qtn2; //向该对象设置欧拉角 这个对象可以将欧拉角转换成四元数 qtn2.setRPY(0,0,0);//偏航角，俯仰角，翻滚角！！单位是弧度 tfs2.transform.rotation.x=qtn2.getX(); tfs2.transform.rotation.y=qtn2.getY(); tfs2.transform.rotation.z=qtn2.getZ(); tfs2.transform.rotation.w=qtn2.getW(); //发布数据 pub.sendTransform(tfs); pub.sendTransform(tfs2); //回旋函数 ros::spin(); return 0; } 结果如下: 订阅者(demo04_static_sub2.cpp) #include \"ros/ros.h\" #include \"tf2_ros/transform_listener.h\"//坐标转换的订阅者对象 #include \"tf2_ros/buffer.h\" #include \"geometry_msgs/PointStamped.h\"//用于传输某个坐标系内坐标点的信息 #include \"tf2_geometry_msgs/tf2_geometry_msgs.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"static_sub\"); ros::NodeHandle nh; //创建buffer缓存对象 tf2_ros::Buffer buffer; //创建监听者对象 可以将订阅的数据（两坐标系关系）存入buffer tf2_ros::TransformListener listenter(buffer); //实例化一个PS坐标 geometry_msgs::PointStamped ps; ps.header.frame_id=\"laser\";//雷达坐标系id ps.header.stamp=ros::Time::now(); //障碍物在雷达坐标系下的坐标 ps.point.x=2.0; ps.point.y=3.0; ps.point.z=5.0; //------ //实例化一个PS坐标 geometry_msgs::PointStamped ps2; ps2.header.frame_id=\"laser2\";//摄像头坐标系id ps2.header.stamp=ros::Time::now(); //障碍物在雷达坐标系下的坐标 ps2.point.x=2.0; ps2.point.y=4.0; ps2.point.z=3.0; ros::Rate rate(10); //ros::Duration(2).sleep();//延迟两秒，等待发布者的启动，将发布的转换关系发生红过来 while (ros::ok()) { try { geometry_msgs::PointStamped ps_out; ps_out=buffer.transform(ps,\"base_link\");//参数一 要转换的坐标 参数二 要转化为的目标坐标系 //这边必须保证转换关系已经订阅到，否则会报错找不到与base_link的关系，所以上面延迟两秒,或者是使用try ROS_INFO(\"转换后的坐标:(%.2f,%.2f,%.2f),原坐标系:%s,目标坐标系:%s\", ps_out.point.x, ps_out.point.y, ps_out.point.z, ps.header.frame_id.c_str(), ps_out.header.frame_id.c_str()); geometry_msgs::PointStamped ps_out2; ps_out2=buffer.transform(ps2,\"base_link\");//参数一 要转换的坐标 参数二 要转化为的目标坐标系 ROS_INFO(\"转换后的坐标dsfdsf:(%.2f,%.2f,%.2f),原坐标系:%s,目标坐标系:%s\", ps_out2.point.x, ps_out2.point.y, ps_out2.point.z, ps2.header.frame_id.c_str(), ps_out2.header.frame_id.c_str()); } catch(const std::exception& e) { //std::cerr 结果如下: 补充：也可以使用命令行直接实现静态的坐标转换关系发布 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part21/1.4.html":{"url":"part21/1.4.html","title":"21.1.4 动态坐标变换","keywords":"","body":"21.1.4 动态坐标变换 所谓动态坐标变换，是指两个坐标系之间的相对位置是变化的。 需求描述: 启动 turtlesim_node,该节点中窗体有一个世界坐标系(左下角为坐标系原点)，乌龟是另一个坐标系，键盘控制乌龟运动，将两个坐标系的相对位置动态发布。 实现分析: 乌龟本身不但可以看作坐标系，也是世界坐标系中的一个坐标点 订阅 turtle1/pose,可以获取乌龟在世界坐标系的 x坐标、y坐标、偏移量以及线速度和角速度 将 pose 信息转换成 坐标系相对信息并发布 发布方代码demo01_dynamic_pub.cpp #include \"ros/ros.h\" #include \"turtlesim/Pose.h\" #include \"tf2_ros/transform_broadcaster.h\" #include \"geometry_msgs/TransformStamped.h\" #include \"tf2/LinearMath/Quaternion.h\" /* 订阅乌龟位置信息，发布乌龟坐标系相对世界坐标系的关系 */ void doPose(const turtlesim::Pose::ConstPtr& p){ static tf2_ros::TransformBroadcaster pub;//静态对象，避免每次进入都重设一个对象 geometry_msgs::TransformStamped tfs; tfs.header.stamp=ros::Time::now(); //tfs.header.seq = 100; tfs.header.frame_id=\"world\";//相对坐标系中被参考的那个，案例里就是小车主体 tfs.child_frame_id=\"turtle1\";//子坐标系，这里是雷达 //偏移量设置 tfs.transform.translation.x=p->x; tfs.transform.translation.y=p->y; tfs.transform.translation.z=0; //四元数设置，需要根据欧拉角转换 tf2::Quaternion qtn; //向该对象设置欧拉角 这个对象可以将欧拉角转换成四元数 //@param roll Angle around X //@param pitch Angle around Y //@param yaw Angle around Z*/ qtn.setRPY(0,0,p->theta);//偏航角，俯仰角，翻滚角！！单位是弧度 tfs.transform.rotation.x=qtn.getX(); tfs.transform.rotation.y=qtn.getY(); tfs.transform.rotation.z=qtn.getZ(); tfs.transform.rotation.w=qtn.getW(); //发布数据 pub.sendTransform(tfs); ROS_INFO(\"乌龟位姿信息:x=%.2f,y=%.2f,theta=%.2f,lv=%.2f,av=%.2f\", p->x,p->y,p->theta,p->linear_velocity,p->angular_velocity ); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); // 2.初始化 ROS 节点 ros::init(argc,argv,\"dynamic_pub\"); // 3.创建 ROS 句柄 ros::NodeHandle nh; // 4.创建订阅者对象 ros::Subscriber sub = nh.subscribe(\"/turtle1/pose\",1000,doPose); // 5.回调函数处理订阅的数据 // 6.spin ros::spin(); return 0; return 0; } 接收方代码demo02_dynamic_sub.cpp #include \"ros/ros.h\" #include \"tf2_ros/transform_listener.h\"//坐标转换的订阅者对象 #include \"tf2_ros/buffer.h\" #include \"geometry_msgs/PointStamped.h\"//用于传输某个坐标系内坐标点的信息 #include \"tf2_geometry_msgs/tf2_geometry_msgs.h\" int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"dynamic_sub\"); ros::NodeHandle nh; //创建buffer缓存对象 tf2_ros::Buffer buffer; //创建监听者对象 可以将订阅的数据（两坐标系关系）存入buffer tf2_ros::TransformListener listenter(buffer); //实例化一个PS坐标 geometry_msgs::PointStamped ps; ps.header.frame_id=\"turtle1\";//雷达坐标系id ps.header.stamp=ros::Time(0,0);//不能用ros::Time::now();了因为会与广播过来存在buffer里面的转化关系的时间戳相比较 //相差太大会认为数据有问题，不给解析，这边直接设置为0，ROS就会不管这边的时间戳是否有问题 //障碍物在乌龟坐标系下的坐标 ps.point.x=2.0; ps.point.y=3.0; ps.point.z=5.0; ros::Rate rate(10); //ros::Duration(2).sleep();//延迟两秒，等待发布者的启动，将发布的转换关系发生红过来 while (ros::ok()) { try { geometry_msgs::PointStamped ps_out; ps_out=buffer.transform(ps,\"world\");//参数一 要转换的坐标 参数二 要转化为的目标坐标系 //这边必须保证转换关系已经订阅到，否则会报错找不到与base_link的关系，所以上面延迟两秒,或者是使用try ROS_INFO(\"转换后的坐标:(%.2f,%.2f,%.2f),参考的坐标系:%s\", ps_out.point.x, ps_out.point.y, ps_out.point.z, ps_out.header.frame_id.c_str()); } catch(const std::exception& e) { //std::cerr Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "},"part21/1.5.html":{"url":"part21/1.5.html","title":"21.1.5 多坐标变换","keywords":"","body":"21.1.5 多坐标变换 需求描述: 现有坐标系统，父级坐标系统 world,下有两子级系统 son1，son2，son1 相对于 world，以及 son2 相对于 world 的关系是已知的，求 son1原点在 son2中的坐标，又已知在 son1中一点的坐标，要求求出该点在 son2 中的坐标 实现分析: 首先，需要发布 son1 相对于 world，以及 son2 相对于 world 的坐标消息 然后，需要订阅坐标发布消息，并取出订阅的消息，借助于 tf2 实现 son1 和 son2 的转换 最后，还要实现坐标点的转换 Copyright &oceanaparts all right reserved，powered by Gitbook该文件修订时间： 2022-03-14 "}}