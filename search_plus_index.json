{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"readme.html":{"url":"readme.html","title":"前言","keywords":"","body":"Introduction "},"part1/readme.html":{"url":"part1/readme.html","title":"1.catkin工作空间","keywords":"","body":"1.catkin工作空间:   catkin时针对ros定制的cmke扩展的编译系统，用来编译ros项目，工作空间就是该项目的文件夹 "},"part1/1.html":{"url":"part1/1.html","title":"1.1具体项目空间建立如下","keywords":"","body":"1.1具体项目空间建立如下： 建立工作空间：~代表在用户文件夹下 mkdir -p ~/项目空间名（文件夹名）/src 定位到工作空间 cd 项目空间名（文件夹名）/ 初始化工作空间，得到build文件夹（中间文件）与devel文件夹（目标文件，动态链接库） catkin_make 进入 src 创建 ros 包（功能包）并添加依赖（roscpp rospy std_msgs） cd src catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 通过上述操作得到 而src下又包含 其中helloworld就是一个功能包 "},"part1/2.html":{"url":"part1/2.html","title":"1.2编译","keywords":"","body":"1.2编译：   命令如下 cd 自定义空间名称 catkin_make source ./devel/setup.bash#编译完成刷新source环境（.代表在当前文件夹下--即上面cd到的空间） source生命周期只有在该终端中生效，关掉重新打开，或同时打开的另一个终端都无法生效，为了方便起见可以使用以下命令加入bashrc文件中，使其一直生效 source ./devel/setup.bash \">>~/.bashrc "},"part2/readme.html":{"url":"part2/readme.html","title":"2.功能包中的src文件夹下分析","keywords":"","body":"2.功能包中的src文件夹下分析（不是与build平级的src): （基于中科院教程https://www.bilibili.com/video/BV1mJ411R7Ni/） src下放的是各种package（功能包），是编译的基本单元，每个package又可以被一同放在一个文件夹下，再放置于src下，每个package可以由各种语言共同构成，一般cpp放在source文件夹下，python放在scripts文件夹下；一个package可以包含多个可执行文件（节点），每个package下除了上述两个代码文件（scripts与source）以及include文件夹又包含着如下两文件（这两文件也是判断是不是package的方法） "},"part2/1.html":{"url":"part2/1.html","title":"2.1 主要文件分析","keywords":"","body":"2.1主要文件分析 CMakeLists.txt 规定catkin编译规则，例如：源文件，依赖项、目标文件， 主要由以下几项构成 具体文件如下 如在第10行就是1.1下第四步的依赖包，如果写错了可以直接修改，记得同时修改xml文件 package.xml 定义了package的属性，例如：包名，版本号，作者，依赖等，主要由以下几项构成 一般修改build_depend与run_depend mainfest.xml 早期版本用rosbuild编译的产物相当于package.xml 代码文件 一般包含脚本文件（shell,python,放置在scripts文件夹下）与C++文件（源文件文件-放置在src文件夹下，头文件-放置在include文件夹下，src下也可放python文件-被其他包import的python文件） 通讯文件 一般是自定义的通信内容，如：消息（.msg），服务（.srv），动作（.action） 其他文件 launch文件（.launch）以及配置文件（.yaml放在config文件夹下） 所以整个src文件架构如下 补充：打印文件夹下的文件架构树可以在该文件下下打开终端然后使用 tree命令 "},"part3/readme.html":{"url":"part3/readme.html","title":"3.常用包管理指令","keywords":"","body":"3.常用包管理指令 （都要在#编译完成刷新source环境前提下执行） "},"part3/1.html":{"url":"part3/1.html","title":"3.1 rospack list ","keywords":"","body":"3.1 rospack list 可以 rospack list | grep 包名 如果没有输出说明没有该包，或没有刷新source，这个命令其实是查找特点关键字的包 "},"part3/2.html":{"url":"part3/2.html","title":"3.2 git clone与安装依赖包","keywords":"","body":"3.2git clone与安装依赖包 （基于中科院教程https://www.bilibili.com/video/BV1mJ411R7Ni/） 补充：在build平级的src下使用 git clone可克隆功能包如: ``` git clone https://ghproxy.com/https://github.com/DroidAITech/ROS-Academy-for-Beginners.git ``` https://ghproxy.com/是国内的代理访问比较快 克隆后rosdep指令使用安装教学包所需的依赖（相关信息在cmakelists与xml文件里），需要在工作空间(此处是catkin_ws)下执行 $ cd ~/catkin_ws $ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y #kinetic应替换作对应的ros版本 对于中科院的教程 发现会报错robot_sim_demo: Cannot locate rosdep definition for [yocs_cmd_vel_mux]无法找到该包，即使apt install 都不行（可能是把yocs-cmd-vel-mux打成yocs_cmd_vel_mux了）需要把 $ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 改成 rosdep install --from-paths ~/catkin_ws/src --ignore-src -r 或者参考以下两链接http://nicethemes.cn/news/txtlist_i142092v.html或https://blog.csdn.net/fanshuaifang/article/details/107100112 克隆后记得编译并刷新环境 $ catkin_make(在工作空间下执行) $ source ~/catkin_ws/devel/setup.bash "},"part3/3.html":{"url":"part3/3.html","title":"3.3 rosls","keywords":"","body":"3.3rosls 与ls类似，查看文件夹下的文件 "},"part4/readme.html":{"url":"part4/readme.html","title":"4.Metpackage","keywords":"","body":"4.Metpackage 包含着各种依赖包，把包组合起来，自身没有实际内容，之前也称作stack，功能包集，软件包集，如ros官方的navigation包，常用包如下 "},"part5/readme.html":{"url":"part5/readme.html","title":"5.常用包管理指令","keywords":"","body":""},"part5/1.html":{"url":"part5/1.html","title":"5.1 master","keywords":"","body":"5.1 master master是节点管理器，每个节点（node）启动时都要向master注册，master管理着节点之间的通信，通过roscore命令启动master，roscore同时还启动了rosout日志输出，主要告诉我们系统有什么error与waring，roscore还启动了parameter server参数服务器 "},"part5/2.html":{"url":"part5/2.html","title":"5.2 node","keywords":"","body":"5.2 node 一个node就是一个进程，之前提到pkg里可以有多个可执行文件（python脚本，c++编译的），运行了这些可执行文件，他们被加载到进程中就成为一个node node的启动：rosrun 包名 连接的C++节点名（也就是源文件映射名称，是CMakeLists中的，如果是py脚本则rosrun 包名 py文件名） 显示某个node的详细信息:rosnode info ros节点名（ros::init的） 列出当前运行的node信息:rosnode list(如果使用rosrun运行的节点显示的是ros::init的节点名，如果是用roslaunch运行的节点则是在launch文件中的name值) 结束某个node：rosnode kill 节点名（ros::init的） ！！！！同时启动多个node: 将信息放在launch文件下后roslaunch 包名 launch文件名.launch并且此命令会自动检查时候运行了roscore没有会自动先启动roscore，并且此命令无需关心在哪个文件夹下执行，但是运行前一样要source "},"part5/3.html":{"url":"part5/3.html","title":"5.3 launch文件","keywords":"","body":"5.3 launch文件 "},"part6/1.html":{"url":"part6/1.html","title":"6.1 Topic通讯","keywords":"","body":"6.1 Topic通讯 两个node要通讯，一般会先定义好共同话题，像一个频道，如下图所示 nodeA调用publish方法发送，nodeB调用subscribe方法订阅。 异步是发送者不管接受者时候收到是否有接受者，不用管消息的反馈，接受者不管发送者是谁 一个Topic可以有多个node订阅，也可以有多个node发送 "},"part6/2.html":{"url":"part6/2.html","title":"6.2 Message","keywords":"","body":"6.2 Message topic内容的数据类型定义在.msg文件中，是topic通讯的数据类型 msg可以嵌套msg，也就是一个msg类型里面可以调用其他类型的msg msg像是一个类或者说结构体，每次发送都是一个该类实例化的对象 常用命令如下： "},"part6/3.html":{"url":"part6/3.html","title":"6.3 Topic与msg具体操作","keywords":"","body":"6.3 Topic与msg具体操作 使用rosnode list查看哪些节点在运行 使用rosnode info 节点名(注意前面的斜杠) 查看节点具体信息 connections后面的topic即使与之相联系的topic频道 使用rostopic info topic名（注意前面的斜杠） 查看topic具体信息 publishers就是这个topic频道的发送者，subscribers就是这个topic频道的接收者 其中的Type信息就是该Topic通讯的msg类，可以使用rosmsg show 这个Type，就能看到这个msg类型的具体组成： rosmsg show msg类型名，显示具体组成 rostopic echo topic名（注意前面的斜杠）显示在该通道里通讯的具体信息（实时的） 使用msg需要修改package.xml文件与cmkelists文件 "},"part6/4.html":{"url":"part6/4.html","title":"6.4 Service通讯","keywords":"","body":"6.4 Service通讯 多用于类似以下场景，一个node需要大量计算资源（如人体姿势识别等深度学习），但是接受的node只是有时候需要，这样的话，如果使用Topic的话，发送的node就是在大量的计算，切是无用的计算，太过占用资源，这就是Topic异步通讯的缺点。 而Service的话nodeA使用request方法，发送参数给nodeB，使nodeB计算，并且nodeA会一直阻塞等待，直到nodeB的计算结果反馈,nodeA才会继续执行 可以多个client对应同一个service >对比如下 "},"part6/5.html":{"url":"part6/5.html","title":"6.5 srv","keywords":"","body":"6.5 srv 与msg之于Topic的关系类似，srv是service通讯的数据格式，定义在.srv文件中,srv里的数据格式可以是定义的msg如下图 DetectHuman.srv是用于人体姿势检测的srv数据格式, bool start_detect是用于request的，为True时执行检测 my_pkg/HumanPose[] pose_data适用于replay的之所以为数组是因为可能检测到的不止一个人，而my_pkg/HumanPose是一种msg 使用msg与srv时需要修改package.xml文件与cmkelists文件 常用命令如下： "},"part6/6.html":{"url":"part6/6.html","title":"6.6 参数服务器Parameter Server","keywords":"","body":"6.6 参数服务器Parameter Server 储存各种参数的字典 可用 **命令行，launch文件和node（API)**等方法进行读写 常用命令行如下： 其中dump与load的文件格式必须遵循yaml格式 也可以在launch.xml文件（主要是各种标签）里对参数进行读写，与参数服务器相关的标签主要是param与rosparam标签 ^第一个标签是 用xacro.py去执行robot.xacro文件得到结果作为字典的value ^第二个标签相当于使用了load命令load了一个yaml文件 "},"part6/7.html":{"url":"part6/7.html","title":"6.7 Service与srv具体操作","keywords":"","body":"6.7 Service与srv具体操作 rosservice info ^Type就是这个service的通讯的srv类型 rossrv show ^srting light_name 是发送的request信息（参数），bool succees与string status_message是reply的信息，这个实例是删除light的实例，返回的信息就是是否删除灯光如下 rosservice call ^后面的\"light_name:''\"是request的参数，可以双击Tab键来自动跳出，补全提示需要什么样的参数 "},"part6/8.html":{"url":"part6/8.html","title":"6.8 rosparam具体操作","keywords":"","body":"6.8 rosparam具体操作 1.rosparam list ：列举所有参数的KEY 2.rosparam get 3.rosparam dump：保存所有参数的yaml文件 4.使用vi命令打开yaml文件 ^注意上面的camera参数字典是字典套字典 "},"part7/1.html":{"url":"part7/1.html","title":"7.1 创建 ROS 工作空间","keywords":"","body":"7.1 创建 ROS 工作空间 mkdir -p 工作空间名/src(必须得有 src)   得到工作空间文件夹（-p指向ubuntu用户文件夹，该实例工作空间命名为demo_service）---Topic实例但是命名为service，这确实是个失误，无伤大雅，主要是后来才发现，来不及修改了   目前在该文件夹下只有src文件夹 cd定位到工作空间文件夹后初始化 cd 工作空间名   该实例就是cd demo_service 接着在该文件夹下初始化工作空间 catkin_make 则工作空间文件夹demo_service下有了build与devel文件夹 "},"part7/2.html":{"url":"part7/2.html","title":"7.2 在工作空间文件夹找下启动 vscode","keywords":"","body":"7.2 在工作空间文件夹找下启动 vscode cd 工作空间文件夹名 code .（后面有个点.不要忘了） 在该实例就是 "},"part7/3.html":{"url":"part7/3.html","title":"7.3 在vscode 中编译 ros（配置编译环境）","keywords":"","body":"7.3 在vscode 中编译 ros（配置编译环境） 1.vs code界面下左键选中src文件夹按下快捷键 ctrl + shift + B 调用编译出现如下选项 点击第二个后面的小齿轮，则出现.vscode文件夹 其中tasks.json文件： 复制粘贴为以下代码 { // 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"catkin_make:debug\", //代表提示的描述性信息 \"type\": \"shell\", //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行 \"command\": \"catkin_make\",//这个是我们需要运行的命令 \"args\": [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2” \"group\": {\"kind\":\"build\",\"isDefault\":true}, \"presentation\": { \"reveal\": \"always\"//可选always或者silence，代表是否输出信息 }, \"problemMatcher\": \"$msCompile\" } ] } 通过以上操作我们完成编译环境配置，后期直接ctrl + shift + B 完成编译 以后如果还需要其实可以直接复制粘贴.vscode文件夹 PS1: 如果没有代码提示修改 .vscode/c_cpp_properties.json设置 \"cppStandard\": \"c++17\" PS2: main 函数的参数不可以被 const 修饰 PS3: 当ROS__INFO 终端输出有中文时，会出现乱码，在代码中加入 setlocale(LC_ALL,\"\");设置编码即可 ------------到上面C++编译环境就创建完成------------ "},"part7/4.html":{"url":"part7/4.html","title":"7.4 创建 ROS 功能包","keywords":"","body":"7.4 创建 ROS 功能包   选定 src 右击 ---> create catkin package，跳出如下选项，输入功能包名，该实例命名为plumbing_pub_sub回车确定   回车后提示输入依赖包，这里输入为常用的roscpp rospy std_msgs，回车确定 "},"part7/5.html":{"url":"part7/5.html","title":"7.5 编写发布者代码","keywords":"","body":"7.5编写发布者代码 在功能包文件夹plumbing_pub_sub下的src右键创建cpp源文件，该实例中命名为demo_pub.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" int main(int argc,char *argv[]) { //2.初始化 ROS 节点:命名(唯一) // 参数1和参数2 后期为节点传值会使用 // 参数3 是节点名称，是一个标识符，需要保证运行后，在 ROS 网络拓扑中唯一 ros::init(argc,argv,\"erGouzhi\"); //3.实例化 ROS 句柄 该类封装了 ROS 中的一些常用功能 ros::NodeHandle nh; //4.实例化 发布者 对象 //泛型: 发布的消息类型 //参数1: 要发布到的话题 //参数2: 队列中最大保存的消息数，超出此阀值时，先进的先销毁(时间早的先销毁) ros::Publisher pub_erGouzhi=nh.advertise(\"demo_service_topic\",10); //实例化一个String 数据 用于存放消息 std_msgs::String demo_service_msg; while(ros::ok()) //节点不死 { demo_service_msg.data=\"hello\"; pub_erGouzhi.publish(demo_service_msg); } return 0; } "},"part7/6.html":{"url":"part7/6.html","title":"7.6 修改CMakeLists.txt文件","keywords":"","body":"7.6修改CMakeLists.txt文件   第136行左右修改 `add_executable`   参数一是节点源文件映射链接名称，自定义，可以不与程序中初始化的节点名称（即上面程序的\"erGouzhi\"）一样   参数二是对应的源文件名称   即修改为如下   第149行左右修改 只需修改参数一，与第136行命名的节点源文件映射链接名称一致，即如下图所示 "},"part7/7.html":{"url":"part7/7.html","title":"7.7 编译运行","keywords":"","body":"7.7编译文件 ctrl + shift + B 输出如下 运行 roscore cd 工作空间文件夹 source ./devel/setup.bash rosrun 包名 C++节点（源文件映射名称,CMakeLists.txt中的add_executable的参数一） "},"part7/8.html":{"url":"part7/8.html","title":"7.8 运行结果分析","keywords":"","body":"7.8 运行结果分析 发现无输出，因为即没有订阅者，也没有日志输出，所以控制台无输出正常 在另一个终端调用rostopic list ,输出如下 发现有/demo_service_topic的topic，则topic正常运行 接着rostopic info +topic话题名称 发现msg类型为std_msgs/String，正是我们所设置的的topic的msg类型 使用rostopic echo +topic话题名称 发现终端一致输出hello符合预期，编写正确 ctrl+c结束rostopic echo的运行（节点依然在运行） "},"part7/9.html":{"url":"part7/9.html","title":"7.9 节点的结束","keywords":"","body":"7.9 节点的结束 使用rosnode kill +节点名称（ros::init的名称），如下图所示 kill后就没有/demo_service_topic的topicle 也没有这个node节点了，使用rosnode list发现节点已经不在运行了 "},"part7/10.html":{"url":"part7/10.html","title":"7.10 完善发布逻辑","keywords":"","body":"7.10 完善发布逻辑 代码修改为如下，实现10hz的发布并完成数据拼接， 输出中文日志信息 #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include int main(int argc,char *argv[]) { //设置编码 避免中文日至输出乱码 setlocale(LC_ALL,\"\"); //2.初始化 ROS 节点:命名(唯一) // 参数1和参数2 后期为节点传值会使用 // 参数3 是节点名称，是一个标识符，需要保证运行后，在 ROS 网络拓扑中唯一 ros::init(argc,argv,\"erGouzhi\"); //3.实例化 ROS 句柄 该类封装了 ROS 中的一些常用功能 ros::NodeHandle nh; //4.实例化 发布者 对象 //泛型: 发布的消息类型 //参数1: 要发布到的话题 //参数2: 队列中最大保存的消息数，超出此阀值时，先进的先销毁(时间早的先销毁) ros::Publisher pub_erGouzhi=nh.advertise(\"demo_service_topic\",10); //实例化一个String 数据 用于存放消息 std_msgs::String demo_service_msg; ros::Rate rate(10);//10hz的频率 int count=0; while(ros::ok()) //节点不死 { count++; //demo_service_msg.data=\"hello\"; //数据拼接 实例化对象 std::stringstream ss; //拼接 ss\"输出结果如下： "},"part7/11.html":{"url":"part7/11.html","title":"7.11 编写订阅者代码","keywords":"","body":"7.11 编写订阅者代码 在功能包文件夹plumbing_pub_sub下的src右键创建订阅者cpp源文件，该实例中命名为demo_sub.cpp 代码如下： /* 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) 消息订阅方: 订阅话题并打印接收到的消息 实现流程: 1.包含头文件 2.初始化 ROS 节点:命名(唯一) 3.实例化 ROS 句柄 4.实例化 订阅者 对象 5.处理订阅的消息(回调函数) 6.设置循环调用回调函数 */ // 1.包含头文件 #include \"ros/ros.h\" #include \"std_msgs/String.h\" void doMsg(const std_msgs::String::ConstPtr& msg_p){ ROS_INFO(\"我听见:%s\",msg_p->data.c_str()); // ROS_INFO(\"我听见:%s\",(*msg_p).data.c_str()); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //2.初始化 ROS 节点:命名(唯一) ros::init(argc,argv,\"listener\"); //3.实例化 ROS 句柄 ros::NodeHandle nh; //4.实例化 订阅者 对象 //泛型: 接收的消息类型 要与发布方一致 //参数1: 要接收的话题 要与发布方一致 ros::Subscriber sub = nh.subscribe(\"demo_service_topic\",10,doMsg); //5.处理订阅的消息(回调函数) // 6.设置循环调用回调函数 不停的调用sub的回调函数doMsg 在调用后不会再返回，也就是你的主程序到这儿就不往下执行了， ros::spin();//循环读取接收的数据，并调用回调函数处理 return 0; } "},"part7/12.html":{"url":"part7/12.html","title":"7.12 修改CMakeLists.txt文件","keywords":"","body":"7.12 修改CMakeLists.txt文件 参考7.6修改为如下图所示： "},"part7/13.html":{"url":"part7/13.html","title":"7.13 编译运行","keywords":"","body":"7.13 编译文件 ctrl + shift + B 运行 在终端中先运行发布者节点（在已经运行roscore前提下，没有就先roscore）： rosrun plumbing_pub_sub demo_pub_node 再新建终端,输入 source ./devel/setup.bash（新开终端了，要重新source） rosrun plumbing_pub_sub demo_sub_node 结果如下，符合预期 "},"part7/14.html":{"url":"part7/14.html","title":"7.14 补充","keywords":"","body":"7.14 补充 补充0: vscode 中的 main 函数 声明 int main(int argc, char const *argv[]){}，默认生成 argv 被 const 修饰，需要去除该修饰符 补充1: ros/ros.h No such file or directory ..... 检查 CMakeList.txt find_package 出现重复,删除内容少的即可 参考资料:https://answers.ros.org/question/237494/fatal-error-rosrosh-no-such-file-or-directory/ 补充2: find_package 不添加一些包，也可以运行啊， ros.wiki 答案如下 You may notice that sometimes your project builds fine even if you did not call find_package with all dependencies. This is because catkin combines all your projects into one, so if an earlier project calls find_package, yours is configured with the same values. But forgetting the call means your project can easily break when built in isolation. 补充3: 订阅时，前几条数据丢，就算先运行订阅者节点再运行发布者节点也会丢失 原因: 发送前几条数据时， publisher 还未在 roscore 注册完毕 （5.1小节--master是节点管理器，每个节点（node）启动时都要向master注册，master管理着节点之间的通信，通过roscore命令启动master），就已经将数据发出，但是未注册，自然无法接受 解决: 注册后，再发送语句前，加入休眠 ros::Duration(3.0).sleep(); 延迟3秒，延迟前几条数据的发送 "},"part7/15.html":{"url":"part7/15.html","title":"7.15 使用launch同时启动多个节点","keywords":"","body":"7.15 使用launch同时启动多个节点 前面需要先输入命令启动发布者节点，再输入命令启动订阅者节点，一旦节点过多，一个个输入命令去启动所有节点是不现实的解决办法就是使用launch文件，可以一次性启动多个ROS节点。 1、在vscode中选定功能包右击 ---> 添加 launch 文件夹2、选定 launch 文件夹右击 ---> 添加 launch 文件，文件名自定义，这里写作start_demo.launch 3、编辑 launch 文件内容 其中 node ---> 包含的某个节点 pkg -----> 功能包名 type ----> 被运行的节点源文件映射名称,即CMakeLists中的add_executable的参数一 name --> 为节点命名，随意取，rosnode list出来的就是这个名字了，而不是CMakeLists中的add_executable的参数一，而rosrun运行节点后rosnode list显示的在程序中初始化的节点名称 output-> 设置日志的输出目标 ，如果程序有日志输出，需要添加该指令，否则无输出。如果用rosrun指令运行节点则不用。 4、ctrl+shift+b编译5、roscore6、在工作空间文件夹下source ./devel/setup.bash7、roslaunch 包名 launch文件名在这里是roslaunch plumbing_pub_sub start_demo.launch8、运行结果如下 "},"part7/16.html":{"url":"part7/16.html","title":"7.16 使用launch运行与rosrun运行结果的区别","keywords":"","body":"7.16 使用launch运行与rosrun运行结果的区别 1、节点名称的差异 观察上面观察上面两个图片可以发现，使用rosrun指令运行，输出日志时，程序中虽然没有标明输出端是屏幕screen，但依旧输出了数据，同时使用rosnode list命令去观察运行的节点名称，可以发现运行的节点名称是程序中节点初始化时的命名名称。而使用roslaunch运行的结果如上面8、所示是节点名称为在launch文件中的name值 2、在日志输出方面的差异 需要指明输出output的值，才可以输出日志。将*.launch文件修改为如下图所示可以发现， 结果如下 两个日志都输出了，只有只有一个日志输出，因为只为发送者节点设置了输出，符合预期 "},"part7/17.html":{"url":"part7/17.html","title":"7.17 计算图查看","keywords":"","body":"7.17 计算图查看 roslaunch plumbing_pub_sub start_demo.launch 运行两节点后 rqt_graph 得到如下结果，将通讯的结构图完整呈现出来 "},"part8/readme.html":{"url":"part8/readme.html","title":"8.Topic通讯操作实例(Python版)--包含vscode运行python环境","keywords":"","body":"8.Topic通讯操作实例(Python版)--包含vscode运行python环境 以下教程基于https://www.bilibili.com/video/BV1Ci4y1L7ZZ/文档http://www.autolabor.com.cn/book/ROSTutorials/实现环境 ubuntu+ros noetic +vscode(安装c/c++,python,ros,cmake tools插件) "},"part8/1.html":{"url":"part8/1.html","title":"8.1 发布方代码编写","keywords":"","body":"8.1 发布方代码编写 在7小节的项目，功能包plumbing_pub_sub目录下创建scripts文件夹，接着在scripts文件夹下创建发布方程序文件，命名为demo_pub_p.py 编写代码（注意第一行#! /usr/bin/env python声明了解释器） #! /usr/bin/env python \"\"\" 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) PS: 二者需要设置相同的话题 消息发布方: 循环发布信息:HelloWorld 后缀数字编号 实现流程: 1.导包 2.初始化 ROS 节点:命名(唯一) 3.实例化 发布者 对象 4.组织被发布的数据，并编写逻辑发布数据 \"\"\" #1.导包 import rospy from std_msgs.msg import String if __name__ == \"__main__\": #2.初始化 ROS 节点:命名(唯一) rospy.init_node(\"talker_p\") #3.实例化 发布者 对象 pub = rospy.Publisher(\"chatter\",String,queue_size=10) #4.组织被发布的数据，并编写逻辑发布数据 msg = String() #创建 msg 对象 msg_front = \"hello 你好\" count = 0 #计数器 # 设置循环频率 rate = rospy.Rate(1) while not rospy.is_shutdown(): #拼接字符串 msg.data = msg_front + str(count) pub.publish(msg) rate.sleep() rospy.loginfo(\"写出的数据:%s\",msg.data) count += 1 "},"part8/2.html":{"url":"part8/2.html","title":"8.2 订阅方代码编写","keywords":"","body":"8.2 订阅方代码编写 在scripts文件夹下创建订阅方程序文件，命名为demo_sub_p.py 编写代码如下（注意第一行#! /usr/bin/env python声明了解释器） #! /usr/bin/env python \"\"\" 需求: 实现基本的话题通信，一方发布数据，一方接收数据， 实现的关键点: 1.发送方 2.接收方 3.数据(此处为普通文本) 消息订阅方: 订阅话题并打印接收到的消息 实现流程: 1.导包 2.初始化 ROS 节点:命名(唯一) 3.实例化 订阅者 对象 4.处理订阅的消息(回调函数) 5.设置循环调用回调函数 \"\"\" #1.导包 import rospy from std_msgs.msg import String def doMsg(msg): rospy.loginfo(\"I heard:%s\",msg.data) if __name__ == \"__main__\": #2.初始化 ROS 节点:命名(唯一) rospy.init_node(\"listener_p\") #3.实例化 订阅者 对象 sub = rospy.Subscriber(\"chatter\",String,doMsg,queue_size=10) #4.处理订阅的消息(回调函数) #5.设置循环调用回调函数 rospy.spin() "},"part8/3.html":{"url":"part8/3.html","title":"8.3 添加可执行权限","keywords":"","body":"8.3 添加可执行权限 终端下进入 scripts 执行: chmod +x *.py PS:就是.py ，不是文件完整名称，这样会对所有python文件添加可执行权限结果如下，单纯 chmod +x .py 没有输出，可以用ll指令 "},"part8/4.html":{"url":"part8/4.html","title":"8.4 配置 CMakeLists.txt","keywords":"","body":"8.4 配置 CMakeLists.txt 165行左右 修改为如下 "},"part8/5.html":{"url":"part8/5.html","title":"8.5编译运行","keywords":"","body":"8.5编译运行 ctrl +shift+b编译 在工作空间下 roscore source ./devel/setup.bash 之后 rosrun plumbing_pub_sub demo_pub_p.py （rosrun 包名 完整py文件名） 结果如下 "},"part9/readme.html":{"url":"part9/readme.html","title":"9.自定义msg","keywords":"","body":"9.自定义msg ROS 中通过 std_msgs 封装了一些原生的数据类型,比如:String、Int32、Int64、Char、Bool、Empty.... 但是，这些数据一般只包含一个 data 字段，结构的单一意味着功能上的局限性，当传输一些复杂的数据，比如: 激光雷达的信息... std_msgs 由于描述性较差而显得力不从心，这种场景下可以使用自定义的消息类型msgs只是简单的文本文件，每行具有字段类型和字段名称，可以使用的字段类型有： int8, int16, int32, int64 (或者无符号类型: uint*) float32, float64 string time, duration other msg files variable-length array[] and fixed-length array[C] ROS中还有一种特殊类型：Header，标头包含时间戳和ROS中常用的坐标帧信息。会经常看到msg文件的第一行具有Header标头。 "},"part9/1.html":{"url":"part9/1.html","title":"9.1 新建与编写msg文件（基于8小节的工程项目下进行）","keywords":"","body":"9.1新建与编写msg文件（基于8小节的工程项目下进行） 在8小节的功能包下右键新建msg文件夹，接着在msg文件夹下右键新建msg文件这里命名为Person.msg，并编写代码，最终如下图所示。 "},"part9/2.html":{"url":"part9/2.html","title":"9.2 修改package.xml文件","keywords":"","body":"9.2修改package.xml文件 原本如下 修改为如下 原理： 是功能包编译时的依赖的相关包 是功能执行时的依赖的相关包 "},"part9/3.1.html":{"url":"part9/3.1.html","title":"9.3.1 find_package修改","keywords":"","body":"9.3.1find_package修改 增加message_generation依赖，这个依赖是帮助我们生成自定义的msg文件的，修改完如下所示 "},"part9/3.2.html":{"url":"part9/3.2.html","title":"9.3.2 add_message_files修改","keywords":"","body":"9.3.2add_message_files修改 原本如下： 增加自己定义的msg文件，即修改为如下： "},"part9/3.3.html":{"url":"part9/3.3.html","title":"9.3.3 generate_messages修改","keywords":"","body":"9.3.3generate_messages修改 这个宏才会真正的把msg文件生成为对应的头文件原本如下： 直接取消注释，即修改为如下，因为欲编译Person.msg需依赖于std_msgs因为在Person.msg中用到的string int32 float32都是std_msgs里的类型 "},"part9/3.4.html":{"url":"part9/3.4.html","title":"9.3.4 catkin_package修改","keywords":"","body":"9.3.4 catkin_package修改 该项是与find_package相联系的，find_package是告诉编译系统，编译这个功能包需要依赖于find_package里的功能包，而find_package里的功能包又得依赖于catkin_package的功能包，如果find_package编写有问题可能导致编译失败，如果catkin_package编写有问题可能导致编译没问题，但是运行时出现问题原本如下： 修改为如下： "},"part9/4.1.html":{"url":"part9/4.1.html","title":"9.4.1 编译后的中间文件查看（C++）","keywords":"","body":"9.4.1编译后的中间文件查看（C++）: C++ 需要调用的中间文件(.../工作空间/devel/include/包名/xxx.h) "},"part9/4.2.html":{"url":"part9/4.2.html","title":"9.4.2 编译后的中间文件查看（Python）","keywords":"","body":"9.4.2编译后的中间文件查看（Python）: C++ 需要调用的中间文件(.../工作空间/devel/lib/python3/dist-packages/msg/xxx.py) "},"part10/1.html":{"url":"part10/1.html","title":"10.1 准备工作-vscode配置","keywords":"","body":"10.1准备工作-vscode配置（c_cpp_properties.json文件修改） 该步一是为了防止误抛异常二是为了代码提示 我们对c_cpp_properties.json 文件进行修改 在这里把刚才生成的C++中间文件--头文件的路径包含过来，可以在vscode右键选中文件后复制路径，在复制的基础上进行修改，复制而来的路径为 /home/rosnoetic/demo_service/devel/include/plumbing_pub_sub/Person.h 把后面的包名以及具体头文件名去掉，改为这样就可以对该路径下的所有的头文件进行包含，不用每次都修改，即修改为如下 /home/rosnoetic/demo_service/devel/include/ 则c_cpp_properties.json原来如下： 修改为： 注意语句后面的逗号不要丢了 "},"part10/2.html":{"url":"part10/2.html","title":"10.2 发布方实现","keywords":"","body":"10.2发布方实现 在src下右键新建demo_msg_pub.cpp文件代码如下：（详见注释） /* 需求: 循环发布人的信息 */ #include \"ros/ros.h\" #include \"plumbing_pub_sub/Person.h\" //消息类头文件的包含,由于在c_cpp_properties中已经包含到include所以这边从plumbing_pub_sub开始 int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //1.初始化 ROS 节点 ros::init(argc,argv,\"talker_person\"); //2.创建 ROS 句柄 ros::NodeHandle nh; //3.创建发布者对象 //<>中是消息类别,这边就是我们自定义的Person类，而该类位于plumbing_pub_sub命名空间下 ros::Publisher pub = nh.advertise(\"chatter_person\",1000); //4.组织被发布的消息，编写发布逻辑并发布消息 plumbing_pub_sub::Person p; p.name = \"张三\"; p.age = 20; p.height = 1.75; ros::Rate r(1); while (ros::ok()) { pub.publish(p); p.age += 1; ROS_INFO(\"我叫:%s,今年%d岁,高%.2f米\", p.name.c_str(), p.age, p.height); r.sleep(); ros::spinOnce(); } return 0; } "},"part10/2.1.html":{"url":"part10/2.1.html","title":"10.2.1修改CMakeList.txt文件","keywords":"","body":"10.2.1修改CMakeList.txt文件 依照7小节的修改方法，增加add_executable与 target_link_libraries宏为如下： 还需增加add_dependencies宏，原来如下：修改为如下： 解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。 "},"part10/2.2.html":{"url":"part10/2.2.html","title":"10.2.2编译运行结果如下：","keywords":"","body":"10.2.2编译运行结果如下： 运行结果分析 符合预期，但是当我们运行rosmsg show时，出现错误，结果如下 因为在该终端我们没有source ./devel/setup.bash， 当source ./devel/setup.bash后在执行rosmsg show时，结果就正常了如下所示 "},"part10/3.html":{"url":"part10/3.html","title":"10.3 订阅方实现","keywords":"","body":"10.3 订阅方实现 在src下右键新建demo_msg_sub.cpp文件代码如下：（详见注释） /* 需求: 订阅人的信息 */ #include \"ros/ros.h\" #include \"plumbing_pub_sub/Person.h\" void doPerson(const plumbing_pub_sub::Person::ConstPtr& person_p){ ROS_INFO(\"订阅的人信息:%s, %d, %.2f\", person_p->name.c_str(), person_p->age, person_p->height); } int main(int argc, char *argv[]) { setlocale(LC_ALL,\"\"); //1.初始化 ROS 节点 ros::init(argc,argv,\"listener_person\"); //2.创建 ROS 句柄 ros::NodeHandle nh; //3.创建订阅对象 ros::Subscriber sub = nh.subscribe(\"chatter_person\",10,doPerson); //4.回调函数中处理 person //5.ros::spin(); ros::spin(); return 0; } "},"part11/1.html":{"url":"part11/1.html","title":" 11.1 准备工作-vscode配置（ settings.json文件修改）","keywords":"","body":"11.自定义msg使用(Python) 11.1准备工作-vscode配置（ settings.json文件修改） 为了方便代码提示以及误抛异常，需要先配置 vscode，将前面生成的 python 文件路径配置进 settings.json 即对 \"python.autoComplete.extraPaths\": 增加如下路径 \"/home/rosnoetic/demo_service/devel/lib/python3/dist-packages/\" 即如下： "},"part11/2.html":{"url":"part11/2.html","title":"11.2 发布方实现","keywords":"","body":"11.2 发布方实现 在scripts文件夹下右键新建文件，这里命名为demo_msg_pub_p.py代码如下 #! /usr/bin/env python \"\"\" 发布方: 循环发送消息 \"\"\" import rospy from plumbing_pub_sub.msg import Person if __name__ == \"__main__\": #1.初始化 ROS 节点 rospy.init_node(\"talker_person_p\") #2.创建发布者对象 pub = rospy.Publisher(\"chatter_person\",Person,queue_size=10) #3.组织消息 p = Person() p.name = \"葫芦瓦\" p.age = 18 p.height = 0.75 #4.编写消息发布逻辑 rate = rospy.Rate(1) while not rospy.is_shutdown(): pub.publish(p) #发布消息 rate.sleep() #休眠 rospy.loginfo(\"姓名:%s, 年龄:%d, 身高:%.2f\",p.name, p.age, p.height) "},"part11/3.html":{"url":"part11/3.html","title":"11.3 订阅方实现","keywords":"","body":"11.3 订阅方实现 在scripts文件夹下右键新建文件，这里命名为demo_msg_sub_p.py代码如下 #! /usr/bin/env python \"\"\" 订阅方: 订阅消息 \"\"\" import rospy from plumbing_pub_sub.msg import Person def doPerson(p): rospy.loginfo(\"接收到的人的信息:%s, %d, %.2f\",p.name, p.age, p.height) if __name__ == \"__main__\": #1.初始化节点 rospy.init_node(\"listener_person_p\") #2.创建订阅者对象 sub = rospy.Subscriber(\"chatter_person\",Person,doPerson,queue_size=10) rospy.spin() #4.循环 "},"part12/1.html":{"url":"part12/1.html","title":"12.1 服务通信自定义srv","keywords":"","body":"12.1 服务通信自定义srv 需求：服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。 "},"part12/1.1.html":{"url":"part12/1.1.html","title":"12.1.1 srv文件创建与代码编写","keywords":"","body":"12.1.1 srv文件创建与代码编写 在前面的项目空间下，首先新建功能包plumbing_server_client添加依赖roscpp rospy std_msgs后，新建文件夹srv，在文件夹下新建文件Addints.srv 代码如下： # 客户端请求时发送的两个数字 int32 num1 int32 num2 --- #分割请求与响应 # 服务器响应发送的数据 int32 sum "},"part12/1.2.html":{"url":"part12/1.2.html","title":"12.1.2 编辑配置文件","keywords":"","body":"12.1.2编辑配置文件 package.xml中添加编译依赖与执行依赖 message_generation message_runtime CMakeLists.txt编辑 srv 相关配置（参考9.3小节）1、find_package宏加入message_generation find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) # 需要加入 message_generation,必须有 std_msgs 2、 add_service_files宏加入AddInts.srv add_service_files( FILES AddInts.srv ) 3、generate_messages添加std_msgs依赖，一般情况写好了，直接取消注释就行 generate_messages( DEPENDENCIES std_msgs ) 4、catkin_package修改原本如下： catkin_package( # INCLUDE_DIRS include # LIBRARIES plumbing_server_client # CATKIN_DEPENDS roscpp rospy std_msgs # DEPENDS system_lib ) 修改为如下： "},"part12/1.3.html":{"url":"part12/1.3.html","title":"12.1.3 编译产生中间文件","keywords":"","body":"12.1.3编译产生中间文件 C++ 需要调用的中间文件(.../工作空间/devel/include/包名/xxx.h) Python 需要调用的中间文件(.../工作空间/devel/lib/python3/dist-packages/包名/srv) "},"part12/2.html":{"url":"part12/2.html","title":"12.2 服务通信自定义srv调用(C++)","keywords":"","body":""},"part12/2.1.html":{"url":"part12/2.1.html","title":"12.2.1 准备工作--vscode配置","keywords":"","body":"12.2 服务通信自定义srv调用(C++) 12.2.1 准备工作--vscode配置 对c_cpp_properties.json的\"includePath\"添加12.1.3中的C++ 的总价两文件的路径，与之前一样，只需要写到include/**就可以，由于之前的话题通讯实例操作已经添加所以这边就不再重复添加了. "},"part12/2.2.html":{"url":"part12/2.2.html","title":"12.2.2 服务器端编写","keywords":"","body":""},"part12/2.2.1.html":{"url":"part12/2.2.1.html","title":"12.2.2.1文件创建于代码编写","keywords":"","body":"12.2.2服务器端编写 12.2.2.1文件创建于代码编写 在src目录下新建demo01_server.cpp，代码编写如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" //回调函数，处理成功返回True bool doNums(plumbing_server_client::Addints::Request &request , plumbing_server_client::Addints::Response &response ){ //1/处理请求 int num1=request.num1; int num2=request.num2; ROS_INFO(\"收到的请求数据:num1=%d,num2=%d\",num1,num2); //2组织响应 int sum=num1+num2; response.sum=sum; ROS_INFO(\"处理的结果为:sum=%d\",sum); //在程序执行出错是会自动返回false，如求商，但分母是0的情况 return true;//没有这句编译也会通过，但会导致执行时无法停下回调函数，一直执行，且前面的接收等也会出错。 } int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"Addints_Server\"); ros::NodeHandle nh; //实例化服务器端 //<>参数省略不写，会根据传递进来的消息自动推导，并且使用rosservice info 时也能推导出符合的消息类型，但是要是传递的消息不符合要求，在回调函数调用成员变量时会出错 ros::ServiceServer server =nh.advertiseService(\"addInts\",doNums); ros::spin(); } "},"part12/2.2.2.html":{"url":"part12/2.2.2.html","title":"12.2.2.2 CMakeLists.txt配置","keywords":"","body":"12.2.2.2 CMakeLists.txt配置 参考10.2.1小节 add_executable项 add_executable(demo01_server_node src/demo01_server.cpp) target_link_libraries项 target_link_libraries(demo01_server_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_server_node ${PROJECT_NAME}_gencpp ) "},"part12/2.2.3.html":{"url":"part12/2.2.3.html","title":"12.2.2.3 编译运行","keywords":"","body":"12.2.2.3编译运行 结果如下: "},"part12/2.3.html":{"url":"part12/2.3.html","title":"12.2.3 客户端编写","keywords":"","body":""},"part12/2.3.1.html":{"url":"part12/2.3.1.html","title":"12.2.3.1 文件创建于代码编写","keywords":"","body":"12.2.3客户端编写 12.2.3.1文件创建于代码编写 在src目录下右键新建文件，这里命名为demo01_client.cpp 代码如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); ros::init(argc,argv,\"Addints_Client\"); ros::NodeHandle nh; //实例化客户端 //<>中为传递的srv数据类 这里是plumbing_server_client命名空间下的Addints ros::ServiceClient client =nh.serviceClient(\"addInts\"); //实例化srv对象 plumbing_server_client::Addints add_srv_1; //对实例化的对象写入数据 add_srv_1.request.num1=100; add_srv_1.request.num2=10; //使用call向client对应的服务器发生请求,并从服务器的回调函数返回标志位，通过写进去的response类型指针，获得回调函数处理结果 bool flag=client.call(add_srv_1); if (flag==true) { ROS_INFO(\"处理成功\"); ROS_INFO(\"client向服务器发生请求后处理返回的结果为:sum=%d\",add_srv_1.response.sum); } else{ ROS_INFO(\"处理失败\"); } } "},"part12/2.3.2.html":{"url":"part12/2.3.2.html","title":"12.2.3.2 CMakeLists.txt配置","keywords":"","body":"12.2.3.2CMakeLists.txt配置 参考12.2.3小节 add_executable项 add_executable(demo01_client_node src/demo01_client.cpp) target_link_libraries项 target_link_libraries(demo01_client_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_client_node ${PROJECT_NAME}_gencpp ) "},"part12/2.3.3.html":{"url":"part12/2.3.3.html","title":"12.2.3.3 编译运行","keywords":"","body":"12.2.3.3编译运行 结果如下: 注意需要先启动服务器端，如果先启动客户端，那么会导致运行失败 "},"part12/2.4.html":{"url":"part12/2.4.html","title":"12.2.4 客户端优化","keywords":"","body":"12.2.4客户端优化 需求优化为可以从键盘接收数据，作为num1与num2发送给服务器处理。 "},"part12/2.4.1.html":{"url":"part12/2.4.1.html","title":"12.2.4.1 代码编写","keywords":"","body":"12.2.4.1代码编写 在src下新建文件demo01_client_optimize.cpp作为优化的客户端的文件。 代码如下: #include \"ros/ros.h\" #include \"plumbing_server_client/Addints.h\" //与demo01_client相比实现参数动态输入 //argc 输入的参数数目 ，在这里我们要实现rosrun 包名 c++节点名 xx(num1,参数一) xx(num2,参数二)一共三个参数（c++节点名,参数一，参数二） //argv就是储存3个参数 int main(int argc,char *argv[]) { setlocale(LC_ALL,\"\"); if(argc!=3) { ROS_INFO(\"未输入num1与num2值，将使用默认参数计算\"); } ros::init(argc,argv,\"Addints_Client_Optimize\");//注意节点名不要重复 ros::NodeHandle nh; //实例化客户端 //<>中为传递的srv数据类 这里是plumbing_server_client命名空间下的Addints ros::ServiceClient client =nh.serviceClient(\"addInts\"); //实例化srv对象 plumbing_server_client::Addints add_srv_1; //对实例化的对象写入数据 if(argc!=3){ add_srv_1.request.num1=100; add_srv_1.request.num2=10; } else{ add_srv_1.request.num1=atoi(argv[1]);//atoi char型转为int型 add_srv_1.request.num2=atoi(argv[2]); ROS_INFO(\"请求为数据:num1=%d,num2=%d\",add_srv_1.request.num1,add_srv_1.request.num2); } //这是一个阻塞式函数，只有服务启动成功后才会继续执行，放在发生请求call之前 或者ros::service::waitForService(\"addInts\"); client.waitForExistence(); //使用call向client对应的服务器发生请求,并从服务器的回调函数返回标志位，通过写进去的response类型指针，获得回调函数处理结果 bool flag=client.call(add_srv_1); if (flag==true) { ROS_INFO(\"处理成功\"); ROS_INFO(\"client向服务器发生请求后处理返回的结果为:sum=%d\",add_srv_1.response.sum); } else{ //不要写else if(flag==false)处理失败不一定是false ROS_INFO(\"处理失败\"); } } "},"part12/2.4.2.html":{"url":"part12/2.4.2.html","title":"12.2.4.2 CMakeLists.txt配置","keywords":"","body":"CMakeLists.txt配置 参考12.3.2小节 add_executable项 add_executable(demo01_client_optimize_node src/demo01_client_optimize.cpp) target_link_libraries项 target_link_libraries(demo01_client_optimize_node ${catkin_LIBRARIES} ) add_dependencies项（解释：参数一与add_executable参数一一致 保证msg先被编译，这样发布方程序里的头文件包含才能被索引到，如果直接先编写msg编译完他再写发布方程序也应该是可以的，但是还是最好这样写以防万一。） add_dependencies(demo01_client_optimize_node ${PROJECT_NAME}_gencpp ) "},"part12/2.4.3.html":{"url":"part12/2.4.3.html","title":"12.2.4.3 编译运行","keywords":"","body":"12.2.4.3编译运行 结果如下： 并且由于 client.waitForExistence(); 语句。 此时可以先启动客户端，会显示等待信息， waitForService: Service [/addInts] is now available. 等待服务器启动.，而不会直接抛出异常。 "},"part12/3.html":{"url":"part12/3.html","title":"12.3 服务通信自定义srv调用(Python)","keywords":"","body":""},"part12/3.1.html":{"url":"part12/3.1.html","title":"12.3.1 准备工作--vscode配置","keywords":"","body":"12.3服务通信自定义srv调用(Python) 12.3.1准备工作--vscode配置 需要像之前自定义 msg 实现一样配置settings.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同: { \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", ] } "},"part12/3.2.html":{"url":"part12/3.2.html","title":"12.3.2 服务器端编写","keywords":"","body":""},"part12/3.2.1.html":{"url":"part12/3.2.1.html","title":"12.3.2.1 文件创建与代码编写","keywords":"","body":"12.3.2服务器端编写 12.3.2.1文件创建与代码编写 在功能包plumbing_server_client文件夹下新建文件夹scripts，在该文件夹下新建服务器代码文件，这里我们命名为命名为demo01_server_p.py。代码如下： #! /usr/bin/env python import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 #from plumbing_server_client.srv import * #直接这样就导入全部包，但是这边不知道为什么出问题了，这样导入不行 def doNum(request): num1=request.num1 num2=request.num2 rospy.loginfo(\"服务器端接受的数据:num1 = %d, num2 = %d\",request.num1, request.num2) sum=num1+num2 #创建一个响应对象 response=AddintsResponse() response.sum=sum rospy.loginfo(\"服务器端接处理的结果为:sum = %d\",response.sum) return response if __name__ == \"__main__\":#注意这边是__不是_ rospy.init_node(\"Addints_Server_p\") server=rospy.Service(\"AddInts_p\",Addints,doNum) rospy.loginfo(\"服务器已经启动了\") rospy.spin() "},"part12/3.2.2.html":{"url":"part12/3.2.2.html","title":"12.3.2.2 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.2.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/ddemo01_server_p.py 编译运行 "},"part12/3.3.html":{"url":"part12/3.3.html","title":"12.3.3客户端编写","keywords":"","body":""},"part12/3.3.1.html":{"url":"part12/3.3.1.html","title":"12.3.3.1 文件创建与代码编写","keywords":"","body":"12.3.3客户端编写 12.3.3.1文件创建与代码编写 在scripts文件夹下新建客户端代码文件，这里我们命名为命名为demo01_server_p.py。代码如下： import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 if __name__ == \"__main__\":#注意这边是__不是_ rospy.init_node(\"Addints_Client_p\") client=rospy.ServiceProxy(\"AddInts_p\",Addints) rospy.loginfo(\"客户端已经启动了\") response=client.call(12,34) #或者 #response=client.call(num1=12,num2=34) rospy.loginfo(\"服务器返回的处理结果为%d\",response.sum) "},"part12/3.3.2.html":{"url":"part12/3.3.2.html","title":"12.3.3.1 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.3.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/ddemo01_client_p.py 编译运行 "},"part12/3.4.html":{"url":"part12/3.4.html","title":"12.3.4 客户端优化","keywords":"","body":"12.3.4客户端优化 需求优化为可以从键盘接收数据，作为num1与num2发送给服务器处 "},"part12/3.4.1.html":{"url":"part12/3.4.1.html","title":"12.3.4.1 代码编写","keywords":"","body":"12.3.4.1代码编写 在scripts文件夹下新建文件demo01_client_optimize_p.py #1.导包 import rospy from plumbing_server_client.srv import Addints,AddintsRequest,AddintsResponse#可以在Addints.py文件去查找 import sys if __name__ == \"__main__\": #优化实现 if len(sys.argv) != 3: rospy.logerr(\"请正确提交参数\") sys.exit(1) # 2.初始化 ROS 节点 rospy.init_node(\"AddInts_Client_p_optimize\") # 3.创建请求对象 client = rospy.ServiceProxy(\"AddInts_p\",Addints) # 请求前，等待服务已经就绪 # 方式1: # rospy.wait_for_service(\"AddInts\") # 方式2 client.wait_for_service() # 4.发送请求,接收并处理响应 # 方式1 # resp = client(3,4) # 方式2 # resp = client(AddIntsRequest(1,5)) # 方式3 req = AddintsRequest() # req.num1 = 100 # req.num2 = 200 #优化 req.num1 = int(sys.argv[1]) req.num2 = int(sys.argv[2]) resp = client.call(req) #上面的四句话可以用下面的代替 num1=int(sys.argv[1]) num2=int(sys.argv[2]) resp = client.call(num1,num2) rospy.loginfo(\"响应结果:%d\",resp.sum) "},"part12/3.4.2.html":{"url":"part12/3.4.2.html","title":"12.3.4.1 添加可执行权限,CMakeLists.txt配置,编译运行","keywords":"","body":"12.3.4.2添加可执行权限 终端下进入 scripts 执行: chmod +x *.py 配置 CMakeLists.txt 对catkin_install_python 宏增加一项 scripts/demo01_client_optimize_p.py 编译运行 "}}